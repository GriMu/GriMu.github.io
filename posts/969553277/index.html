<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>JAVA学习 | 才学浅</title><meta name="keywords" content="JAVA,笔记"><meta name="author" content="ChengZC"><meta name="copyright" content="ChengZC"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="JAVA学习"><meta name="application-name" content="JAVA学习"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta name="description" content="annotation元注解：12341. @Target2. @Document3. @Retention4. @Inherited   @Target，注解的修饰的范围1234561. ElementType.CONSTRUCTOR 构造器2. ElementType.METHOD 方法3. ElementType.FIELD 属性4. ElementType.TYPE 接口或者类5. Elem">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA学习">
<meta property="og:url" content="https://chengzc.club/posts/969553277/index.html">
<meta property="og:site_name" content="才学浅">
<meta property="og:description" content="annotation元注解：12341. @Target2. @Document3. @Retention4. @Inherited   @Target，注解的修饰的范围1234561. ElementType.CONSTRUCTOR 构造器2. ElementType.METHOD 方法3. ElementType.FIELD 属性4. ElementType.TYPE 接口或者类5. Elem">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://czcsw-1256525464.cos.ap-chengdu.myqcloud.com/images/blog/20230414/1681405751001/900000100.jpg">
<meta property="article:published_time" content="2019-01-23T01:12:10.000Z">
<meta property="article:modified_time" content="2023-04-13T17:28:03.066Z">
<meta property="article:author" content="ChengZC">
<meta property="article:tag" content="JAVA">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://czcsw-1256525464.cos.ap-chengdu.myqcloud.com/images/blog/20230414/1681405751001/900000100.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://chengzc.club/posts/969553277/"><link rel="preconnect" href="//npm.elemecdn.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://npm.elemecdn.com/@fortawesome/fontawesome-free@6.3.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/@fancyapps/ui@4.0.31/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  friends_vue_info: {"apiurl":"https://friend.chengzc.club/"},
  navMusic: true,
  changeMainColorPost: true,
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#3b70fc","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://npm.elemecdn.com/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://npm.elemecdn.com/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JAVA学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-14 01:28:03'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<style>#recent-posts{margin-top:-1rem;align-content:flex-start;display:flex;flex-wrap:wrap;justify-content:space-between}#recent-posts>.recent-post-item{margin-top:1rem;display:inline-block;height:auto;width:49%}#recent-posts>.recent-post-item .post_cover{width:100%;height:200px}#recent-posts>.recent-post-item .post_cover img.post_bg{width:100%;height:100%}#recent-posts>.recent-post-item>.recent-post-info>.content{display:none}#recent-posts>.recent-post-item{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}#recent-posts>.recent-post-item .left_radius{border-radius:8px 8px 0 0}#recent-posts>.recent-post-item .right_radius{border-radius:8px 8px 0 0}.recent-post-item{height:auto!important}.recent-post-info{padding:0 40px;margin-top:1em;width:100%!important}#recent-posts>.recent-post-item>.recent-post-info>.article-title{-webkit-line-clamp:1;margin-top:.3rem;margin-bottom:.3rem;color:var(--text-highlight-color);font-size:1.2em;line-height:1.4}#recent-posts>.recent-post-item>.recent-post-info>.article-meta-wrap{margin-bottom:1rem}@media screen and (max-width:768px){#recent-posts>.recent-post-item{width:100%}}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="才学浅" type="application/atom+xml">
</head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://czcsw-1256525464.cos.ap-chengdu.myqcloud.com/images/blog/20230401/Misaka.jpg"/><div class="loading-image-dot"></div><div id="loading-percentage">0%</div></div></div><script>const loadingPercentage = document.getElementById("loading-percentage");
let loadingPercentageTimer = setInterval(function() {
  var progressBar = document.querySelector(".pace-progress");
  if (!progressBar) return
  var currentValue = progressBar.getAttribute("data-progress-text");
  if (currentValue !== loadingPercentage.textContent) {
    loadingPercentage.textContent = currentValue;
    if (currentValue === "100%") {
      clearInterval(loadingPercentageTimer);
    }
  }
}, 100);
const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
    Pace.restart()
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/progress_bar/progress_bar.css"/><script async="async" src="https://npm.elemecdn.com/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div id="web_box"><div id="web_container"><div id="menu-mask"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://chengzc.club/" title="博客" target="_blank"><img class="back-menu-item-icon" src="https://czcsw-1256525464.cos.ap-chengdu.myqcloud.com/images/blog/20230401/Misaka.jpg" alt="博客"/><span class="back-menu-item-text">博客</span></a><a class="back-menu-item" href="https://doc.chengzc.club/" title="文档管理" target="_blank"><img class="back-menu-item-icon" src="https://czcsw-1256525464.cos.ap-chengdu.myqcloud.com/images/blog/20230402/Entypo_2712%280%29.ico" alt="文档管理"/><span class="back-menu-item-text">文档管理</span></a><a class="back-menu-item" href="https://fly.chengzc.club/" title="同步文件" target="_blank"><img class="back-menu-item-icon" src="https://czcsw-1256525464.cos.ap-chengdu.myqcloud.com/images/blog/20230402/favicon-96x96.png" alt="同步文件"/><span class="back-menu-item-text">同步文件</span></a><a class="back-menu-item" href="https://chatai.chengzc.club/" title="Chagpt Ai" target="_blank"><img class="back-menu-item-icon" src="https://czcsw-1256525464.cos.ap-chengdu.myqcloud.com/images/blog/20230402/favicon.svg" alt="Chagpt Ai"/><span class="back-menu-item-text">Chagpt Ai</span></a><a class="back-menu-item" href="https://img.chengzc.club/" title="Lsky图床" target="_blank"><img class="back-menu-item-icon" src="https://img.chengzc.club/favicon.ico" alt="Lsky图床"/><span class="back-menu-item-text">Lsky图床</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" href="https://github.com/GriMu/uni-bimitv" title="uni-bimitv" target="_blank"><img class="back-menu-item-icon" src="https://czcsw-1256525464.cos.ap-chengdu.myqcloud.com/images/blog/20230402/github.svg" alt="uni-bimitv"/><span class="back-menu-item-text">uni-bimitv</span></a><a class="back-menu-item" href="https://github.com/GriMu/bimi-api" title="bimi-api" target="_blank"><img class="back-menu-item-icon" src="https://czcsw-1256525464.cos.ap-chengdu.myqcloud.com/images/blog/20230402/github.svg" alt="bimi-api"/><span class="back-menu-item-text">bimi-api</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">才学浅</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=8295035317&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> Search</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://czcsw-1256525464.cos.ap-chengdu.myqcloud.com/images/blog/wechat_pay.jpeg" target="_blank"><img class="post-qr-code-img" alt="wechat" src="https://czcsw-1256525464.cos.ap-chengdu.myqcloud.com/images/blog/wechat_pay.jpeg"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://czcsw-1256525464.cos.ap-chengdu.myqcloud.com/images/blog/alipay.jpeg" target="_blank"><img class="post-qr-code-img" alt="alipay" src="https://czcsw-1256525464.cos.ap-chengdu.myqcloud.com/images/blog/alipay.jpeg"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments" onclick="anzhiyu.hideConsole()"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> <span>Newest Comments</span></span></div><div class="aside-list"><span>loading...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags" onclick="anzhiyu.hideConsole()"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/JAVA/" style="font-size: 1.05rem; color: rgb(48, 118, 131);">JAVA<sup>2</sup></a><a href="/tags/Jenkins/" style="font-size: 1.05rem; color: rgb(83, 114, 26);">Jenkins<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem; color: rgb(177, 144, 116);">Linux<sup>2</sup></a><a href="/tags/Markdown/" style="font-size: 1.05rem; color: rgb(123, 37, 50);">Markdown<sup>2</sup></a><a href="/tags/Play/" style="font-size: 1.05rem; color: rgb(167, 94, 18);">Play<sup>1</sup></a><a href="/tags/RocketMq/" style="font-size: 1.05rem; color: rgb(13, 104, 126);">RocketMq<sup>1</sup></a><a href="/tags/chatgpt/" style="font-size: 1.05rem; color: rgb(110, 195, 45);">chatgpt<sup>4</sup></a><a href="/tags/git/" style="font-size: 1.05rem; color: rgb(39, 79, 39);">git<sup>4</sup></a><a href="/tags/hexo/" style="font-size: 1.05rem; color: rgb(111, 160, 129);">hexo<sup>1</sup></a><a href="/tags/java/" style="font-size: 1.05rem; color: rgb(78, 175, 18);">java<sup>2</sup></a><a href="/tags/nginx/" style="font-size: 1.05rem; color: rgb(9, 23, 5);">nginx<sup>1</sup></a><a href="/tags/php/" style="font-size: 1.05rem; color: rgb(190, 182, 44);">php<sup>1</sup></a><a href="/tags/python/" style="font-size: 1.05rem; color: rgb(143, 183, 133);">python<sup>1</sup></a><a href="/tags/spring-boot/" style="font-size: 1.05rem; color: rgb(106, 169, 135);">spring-boot<sup>1</sup></a><a href="/tags/ssl/" style="font-size: 1.05rem; color: rgb(37, 41, 120);">ssl<sup>1</sup></a><a href="/tags/tomcat/" style="font-size: 1.05rem; color: rgb(161, 200, 41);">tomcat<sup>1</sup></a><a href="/tags/%E5%90%8C%E6%AD%A5/" style="font-size: 1.05rem; color: rgb(126, 26, 52);">同步<sup>1</sup></a><a href="/tags/%E5%9F%9F%E5%90%8D/" style="font-size: 1.05rem; color: rgb(170, 134, 20);">域名<sup>1</sup></a><a href="/tags/%E5%A3%B0%E5%8D%A1/" style="font-size: 1.05rem; color: rgb(115, 13, 77);">声卡<sup>1</sup></a><a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 1.05rem; color: rgb(200, 187, 141);">工具<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 1.05rem; color: rgb(95, 116, 17);">数据库<sup>1</sup></a><a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 1.05rem; color: rgb(167, 101, 11);">服务器<sup>2</sup></a><a href="/tags/%E7%A0%81%E4%BA%91/" style="font-size: 1.05rem; color: rgb(111, 99, 183);">码云<sup>1</sup></a><a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 1.05rem; color: rgb(13, 183, 146);">笔记<sup>1</sup></a><a href="/tags/%E7%BC%96%E8%AF%91/" style="font-size: 1.05rem; color: rgb(45, 113, 60);">编译<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history" onclick="anzhiyu.hideConsole()"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>Archives</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">May 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/04/"><span class="card-archive-list-date">April 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2020/04/"><span class="card-archive-list-date">April 2020</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2019/03/"><span class="card-archive-list-date">March 2019</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2019/02/"><span class="card-archive-list-date">February 2019</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2019/01/"><span class="card-archive-list-date">January 2019</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2018/10/"><span class="card-archive-list-date">October 2018</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" onclick="anzhiyu.switchDarkMode()" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div><div class="console-btn-item" id="consoleKeyboard" onclick="anzhiyu.keyboardToggle()" title="快捷键开关"><a class="keyboard-switch"><i class="anzhiyufont anzhiyu-icon-keyboard"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"><a class="article-meta__tags" href="/tags/JAVA/" tabindex="-1"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>JAVA</span></a><a class="article-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/" tabindex="-1"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>笔记</span></a></span></div></div><h1 class="post-title">JAVA学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2019-01-23T01:12:10.000Z" title="Created 2019-01-23 09:12:10">2019-01-23</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-04-13T17:28:03.066Z" title="Updated 2023-04-14 01:28:03">2023-04-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">Word count:</span><span class="word-count" title="文章字数">32.2k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">Reading time:</span><span>99min</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="JAVA学习"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">Post View:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为武汉"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>武汉</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://czcsw-1256525464.cos.ap-chengdu.myqcloud.com/images/blog/20230414/1681405751001/900000100.jpg"></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="annotation"><a href="#annotation" class="headerlink" title="annotation"></a>annotation</h1><h2 id="元注解："><a href="#元注解：" class="headerlink" title="元注解："></a>元注解：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. @Target</span><br><span class="line">2. @Document</span><br><span class="line">3. @Retention</span><br><span class="line">4. @Inherited</span><br></pre></td></tr></table></figure>


<h2 id="Target，注解的修饰的范围"><a href="#Target，注解的修饰的范围" class="headerlink" title="@Target，注解的修饰的范围"></a>@Target，注解的修饰的范围</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. ElementType.CONSTRUCTOR 构造器</span><br><span class="line">2. ElementType.METHOD 方法</span><br><span class="line">3. ElementType.FIELD 属性</span><br><span class="line">4. ElementType.TYPE 接口或者类</span><br><span class="line">5. ElementType.PARAMETER 参数</span><br><span class="line">6. ElementType.PACKAGE 包</span><br></pre></td></tr></table></figure>


<h2 id="Retention-注释修饰的时间"><a href="#Retention-注释修饰的时间" class="headerlink" title="Retention 注释修饰的时间"></a>Retention 注释修饰的时间</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. RetentionPolicy.RESOURCE 源文件保留</span><br><span class="line">2. RetentionPolicy.RUNTIME 运行时保留</span><br><span class="line">3. RetentionPolicy.CLASS class文件保留</span><br></pre></td></tr></table></figure>


<h2 id="Inherited-元注解的一个标记注解，被标注的类型是被继承的。"><a href="#Inherited-元注解的一个标记注解，被标注的类型是被继承的。" class="headerlink" title="@Inherited 元注解的一个标记注解，被标注的类型是被继承的。"></a>@Inherited 元注解的一个标记注解，被标注的类型是被继承的。</h2><h1 id="cdn"><a href="#cdn" class="headerlink" title="cdn"></a>cdn</h1><h2 id="CDN简介："><a href="#CDN简介：" class="headerlink" title="CDN简介："></a>CDN简介：</h2><p>CDN就是内容分发网络 <code>Content Delivery NetWork</code>，构建在Internet上一种先进的流量分配网络。在现有的Internet<br>中添加一层新的网络架构，将网络内容分发到离用户最近的网络边缘，使用户可以就近取得所需的内容。</p>
<h2 id="CDN缓存内容："><a href="#CDN缓存内容：" class="headerlink" title="CDN缓存内容："></a>CDN缓存内容：</h2><p>目前CDN都以缓存网站中静态数据为主，如CSS. JS. 图片和静态页面等数据。用户在主站服务器请求到动态内容后，再从CDN上下载<br>这些静态数据，从而加速网站数据内容的下载速度。</p>
<h2 id="CDN要达到的目标："><a href="#CDN要达到的目标：" class="headerlink" title="CDN要达到的目标："></a>CDN要达到的目标：</h2><ol>
<li>可扩展性. 2. 安全性. 3. 可靠性. 响应和执行</li>
</ol>
<h2 id="负载均衡："><a href="#负载均衡：" class="headerlink" title="负载均衡："></a>负载均衡：</h2><ol>
<li>链路负载均衡：DNS解析成不同IP</li>
<li>集群负载均衡：由硬件和软件负载均衡</li>
<li>系统负载均衡：利用操作系统级别的软中断和硬中断来达到负载均衡，例如可以设置多列网卡。</li>
</ol>
<h2 id="CDN动态加速"><a href="#CDN动态加速" class="headerlink" title="CDN动态加速"></a>CDN动态加速</h2><ol>
<li>CDN动态加速原理；在CDN的DNS解析中，通过动态的链路探测来寻找回源最好的一条路径，然后将DNS调度将所有请求调度到选定<br>的这条路径上回源，从而加速用户的访问效率。</li>
<li>如何选择源站链路最好的路径让用户走，一个简单的原则就是在每个CDN节点上，从源站下载一个一定大小的文件，看哪个路径耗时最短，<br>可以构成一个链路列表，绑定到DNS解析上。</li>
</ol>
<h1 id="class"><a href="#class" class="headerlink" title="class"></a>class</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>1：任何一个Class文件都对应唯一一个类或者接口的定义信息。Class文件是一组8位字节码为基础单位的二进制流，各个项目岩哥按照顺序紧凑的排列在Class文件中，中间没有添加任何的分隔符，Class文件存储的几乎是全部的必要数据。<br>2：Class文件格式采用二中类型数据：无符号数和表。无符号数：无符号数属于基本数据类型，用来描述数字. 索引引用. 数量值或者按照UTF-8编码组成的字符串。表：是由多个无符号数或者其他表作为数据项构成的符合数据类型，所有的表都习惯性的以”_info”结尾。<br>3：每个Class文件的头4个字节成为”魔数”，它的唯一作用就是确定这个文件是否为一个能够被虚拟机接受的Class文件，很多文件存储标准中都使用魔数来进行身份识别。<br>4：Class文件的魔数值为oxCAFEBABE</p>
<h2 id="类的加载时机"><a href="#类的加载时机" class="headerlink" title="类的加载时机"></a>类的加载时机</h2><ol>
<li>类从加载到虚拟机内存开始，到卸载出内存位置。它的生命周期包括：加载. 连接. 初始化. 使用. 卸载。连接：验证. 准备. 解析。</li>
</ol>
<h2 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h2><ol>
<li>遇到new. getstatic. putstatic或invokestatic这4条字节码指令的时候，如果类没有初始化，则需要初始化。new创建一个对象，获取或者设置静态属性. 调用静态方法时，需要初始化。</li>
<li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，发现其父类没有初始化，则需要先触发其父类的初始化。</li>
<li>当使用jdk7动态语言支持时，有些方法句柄对应的类，没有进行初始化，需要触发其初始化。</li>
</ol>
<h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><ol>
<li>在加载阶段，虚拟机需要完成一下3件事情，1：通过一个类的权限名来获取定义此类的二进制字节流。<br>2：将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构。3：在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<h2 id="类加载过程："><a href="#类加载过程：" class="headerlink" title="类加载过程："></a>类加载过程：</h2><ol>
<li>加载：查找和导入class文件</li>
<li>连接：<br>  2.1：验证：检查载入Class文件是否符合JVM规范。<br>  2.2：准备：将静态变量分配存储空间。<br>  2.3：解析：将符号引用，转换成直接引用。</li>
<li>初始化：对类的静态变量，静态代码块初始化操作。</li>
</ol>
<h2 id="类的加载过程："><a href="#类的加载过程：" class="headerlink" title="类的加载过程："></a>类的加载过程：</h2><ol>
<li>类的主动引用（一定会发生类的初始化）<br>1.1 new一个类的对象<br>1.2 调用一个类的静态成员或者静态方法<br>1.3 使用反射方法对类进行反射调用<br>1.4 启动main方法所在的类<br>1.5 当初始化一个类时，其父类如果没有被初始化，则先初始化父类</li>
<li>类的被动引用（不会发生类的初始化）<br>2.1 当访问一个静态域时，只有真正声明的这个类才会被初始化<br> 通过子类引用父类的静态变量，子类不会被初始化<br>2.2 通过数组定义引用类，不会触发类的初始化<br>2.3 引用常量不会触发此类的初始化</li>
</ol>
<h2 id="类加载器的代理模式："><a href="#类加载器的代理模式：" class="headerlink" title="类加载器的代理模式："></a>类加载器的代理模式：</h2><ol>
<li>代理模式：交给其他加载器来加载指定的类</li>
<li>双亲委托机制：在加载类时，首先将加载任务交给父类加载器加载。双亲委托机制是为了保证java核心类库的类型安全。</li>
</ol>
<h2 id="类加载器的层次结构："><a href="#类加载器的层次结构：" class="headerlink" title="类加载器的层次结构："></a>类加载器的层次结构：</h2><ol>
<li>引导类加载器（根加载器）</li>
<li>扩展类加载器</li>
<li>应用程序加载器</li>
<li>自定义加载器</li>
</ol>
<h2 id="线程上下文加载器："><a href="#线程上下文加载器：" class="headerlink" title="线程上下文加载器："></a>线程上下文加载器：</h2><ol>
<li>当需要动态加载资源的时候，你至少有三个classloader可以选择：<br>1.1系统类加载器叫做应用加载器<br>1.2当前类加载器<br>1.3当前线程加载器<br>1.4线程类加载器是为了抛弃双亲委派加载链模式<br>每个线程都有一个关联的上下文类加载器。如果使用new Thread方式生成新的线程，新线程将继承父线程的上下文加载器</li>
</ol>
<h1 id="concurrent"><a href="#concurrent" class="headerlink" title="concurrent"></a>concurrent</h1><ul>
<li>jdk1.5以后，推出了java.util.concurrent包</li>
<li>Executor：具体的Runnable的执行者</li>
<li>ExecutorService：一个线程池的管理者，其实现类有很多，可以把Runnable. Callable提交到线程池中调用。</li>
<li>Semaphore：信号量。</li>
<li>ReentrantLock：可重入的互斥锁。</li>
<li>Future：与Runnable. Callable接口进行交互。</li>
<li>BlockingQueue：阻塞队列。</li>
<li>CompletionService:ExecutorService的扩展，可以活得最先执行完线程的结果，底层实现是通过阻塞队列。</li>
<li>CountDownLatch：一个同步辅助类，完成一组正在其他线程中执行的操作之前，允许一个或者多个线程一直等待。</li>
<li>CyclicBarrier：一个同步辅助类，它允许一组线程互相等待，直到达到某个屏障点。</li>
<li>CopyOnWriteArrayList：</li>
</ul>
<ol>
<li>在CopyOnWriteArrayList在处理写（包括add. set. remove）操作的时候，先将原始数据通过Array.copyOf来生成一个新的数组，<br>在新的数据对象上写，写完后再将原来的引用指向当前的数据对象，并加锁。</li>
<li>读操作在引用的当前引用的对象上进行读，不存在加锁和阻塞。</li>
<li>因为每次使用CopyOnWriteArrayList.add都要引起数组拷贝，所以应该避免在循环中使用。可以在初始化完成之后设置到CopyeOnWriteArrayList中，或者使用CopyOnWriteArrayList.addAll方法。</li>
<li>CopyOnWriteArrayList采用“写入时复制”策略，对容器的写操作将导致的容器中基本数据的复制，性能开销较大。所以在有写操作的情况下，CopyOnWriteArayList性能不佳，而且如果容器容量较大的话容易造成溢出。</li>
</ol>
<ul>
<li><p>线程池不允许使用 Executors 去创建,而是通过 ThreadPoolExecutor 的方式,这样 的处理方式让写的同学更加明确线程池的运行规则,规避资源耗尽的风险。<br>说明:Executors 返回的线程池对象的弊端如下:<br>1)FixedThreadPool 和 SingleThreadPool:<br>允许的请求队列长度为 Integer.MAX_VALUE,可能会堆积大量的请求,从而导致 OOM。<br>2)CachedThreadPool 和 ScheduledThreadPool:<br>允许的创建线程数量为 Integer.MAX_VALUE,可能会创建大量的线程,从而导致 OOM。</p>
</li>
<li><p>SimpleDateFormat 是线程不安全的类,一般不要定义为static变量,如果定义为static,必须加锁,或者使用 DateUtils 工具类。</p>
</li>
</ul>
<p>正例:注意线程安全,使用 DateUtils。亦推荐如下处理:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static final ThreadLocal&lt;DateFormat&gt; df = new ThreadLocal&lt;DateFormat&gt;() &#123; @Override</span><br><span class="line">protected DateFormat initialValue() &#123;</span><br><span class="line">return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line"> &#125;;&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><p>高并发时,同步调用应该去考量锁的性能损耗。能用无锁数据结构,就不要用锁;能 锁区块,就不要锁整个方法体;能用对象锁,就不要用类锁。</p>
</li>
<li><p>对多个资源. 数据库表. 对象同时加锁时,需要保持一致的加锁顺序,否则可能会造 成死锁。<br>说明:线程一需要对表 A. B. C 依次全部加锁后才可以进行更新操作,那么线程二的加锁顺序 也必须是 A. B. C,否则可能出现死锁。</p>
</li>
<li><p>并发修改同一记录时,避免更新丢失,要么在应用层加锁,要么在缓存加锁,要么在 数据库层使用乐观锁,使用 version 作为更新依据。<br>说明:如果每次访问冲突概率小于20%,推荐使用乐观锁,否则使用悲观锁。乐观锁的重试次数不得小于3次。</p>
</li>
<li><p>多线程并行处理定时任务时,Timer 运行多个 TimeTask 时,只要其中之一没有捕获 抛出的异常,其它任务便会自动终止运行,使用 ScheduledExecutorService 则没有这个问题。</p>
</li>
<li><p>使用 CountDownLatch 进行异步转同步操作,每个线程退出前必须调用 countDown方法,线程执行代码注意 catch 异常,<br>确保 countDown 方法可以执行,避免主线程无法执行 至 countDown 方法,直到超时才返回结果。 说明:注意,子线程抛出异常堆栈,不能在主线程 try-catch 到。</p>
</li>
<li><p>避免 Random 实例被多线程使用,虽然共享该实例是线程安全的,但会因竞争同一 seed 导致的性能下降。<br>说明:Random 实例包括 java.util.Random 的实例或者 Math.random()实例。<br>正例:在 JDK7 之后,可以直接使用 API ThreadLocalRandom,在 JDK7 之前,可以做到每个 线程一个实例。</p>
</li>
<li><p>volatile 解决多线程内存不可见问题。对于一写多读,是可以解决变量同步问题, 但是如果多写,同样无法解决线程安全问题。如果是 count++操作,使用如下类实现:<br>AtomicInteger count &#x3D; new AtomicInteger(); count.addAndGet(1);如果是 JDK8,推 荐使用 LongAdder 对象,比 AtomicLong 性能更好(减少乐观锁的重试次数)。</p>
</li>
<li><p>HashMap 在容量不够进行 resize 时由于高并发可能出现死链,导致 CPU 飙升,在 开发过程中注意规避此风险</p>
</li>
<li><p>ThreadLocal 无法解决共享对象的更新问题,ThreadLocal 对象建议使用 static 修饰。<br>这个变量是针对一个线程内所有操作共有的,所以设置为静态变量,所有此类实例共享 此静态变量 ,也就是说在类第一次被使用时装载,只分配一块存储空间,所有此类的对象(只 要是这个线程内定义的)都可以操控这个变量。</p>
</li>
</ul>
<h1 id="core"><a href="#core" class="headerlink" title="core"></a>core</h1><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><ol>
<li>volatile修饰的变量，可以保证从主内存加载到线程内存的值是最新的。</li>
<li>volatile可以防止指令重排序。</li>
</ol>
<h2 id="单例模式失效"><a href="#单例模式失效" class="headerlink" title="单例模式失效"></a>单例模式失效</h2><p>双重锁检测，可能会失效。原因在于：初始化Singleton和将地址写入到instance字段的顺序是不确定的。在某个线程new Singleton()时，在构造方法之前，就为<br>该对象分配了内存空间并将对象的字段设置成默认值。此时就可以将分配的内存地址赋值给instance字段了，然而改对象可能还没有初始化；此时若另外一个线程来调用<br>getInstance，渠道的状态就是不正确的对象。</p>
<h2 id="一致性Hash算法"><a href="#一致性Hash算法" class="headerlink" title="一致性Hash算法"></a>一致性Hash算法</h2><ol>
<li>一个分布式系统，要将数据存储到具体的节点。如果普通的hash方法，将数据映射到具体的节点上，如key%N，key是数据的key，N是机器节点，如果有一个机器加入<br>或者退出这个集群，则所有的数据映射都无效，如果是持久化存储则要做数据迁移，如果是分布式存储，则其他存储就失效了。</li>
<li>把数据用户hash函数（如MD5），映射到一个很大的空间。数据的存储时，先得到一个hash值，对应到这个环上的每个位置。数据沿着顺时针找到一个机器节点，将数据<br>存储到这个机器上。</li>
<li>当其中一个机器节点挂掉后，另外一个节点会承担挂掉节点的数据，另外一个节点很容易宕机。</li>
<li>引入”虚拟节点”的概念：即把想象在这个环上有很多“虚拟节点”，数据的存储是沿着环的顺时针方向找一个虚拟节点，每个虚拟节点都会关联到一个真实节点。由于这些<br>虚拟节点数量很多，均匀分布，因此不会造成“雪崩”现象。</li>
</ol>
<h2 id="equals-和-hashcode"><a href="#equals-和-hashcode" class="headerlink" title="equals 和 hashcode"></a>equals 和 hashcode</h2><p>在Java中任何一个对象都具备equals(Object obj)和hashcode()这两个方法，因为他们是在Object类中定义的。<br>equals(Object obj)方法用来判断两个对象是否“相同”，如果“相同”则返回true，否则返回false。<br>hashcode()方法返回一个int数，在Object类中的默认实现是“将该对象的内部地址转换成一个整数返回”。<br>若重写equals(Object obj)方法，有必要重写hashcode()方法，确保通过equals(Object obj)方法判断结果为true的两个对象具备相等的hashcode()返回值<br>Oject类中的equals方法用来比较两个引用值，hashCode用来返回引用的内地址的十六进制数值。在Set以及Map集合中，判断两个元素是否重复时，往往需要使用这两个方法。这两个方法往往被子类覆盖</p>
<ol>
<li><p>如果两个对象equals，Java运行时环境会认为他们的hashcode一定相等。 </p>
</li>
<li><p>如果两个对象不equals，他们的hashcode有可能相等。 </p>
</li>
<li><p>如果两个对象hashcode相等，他们不一定equals。 </p>
</li>
<li><p>如果两个对象hashcode不相等，他们一定不equals。<br>for testsdsdsd</p>
</li>
<li><p>如果两个对象hashcode相等，他们不一定equals。</p>
</li>
<li><p>如果两个对象hashcode不相等，他们一定不equals。</p>
</li>
</ol>
<h1 id="design"><a href="#design" class="headerlink" title="design"></a>design</h1><h2 id="设计模式的六大原则："><a href="#设计模式的六大原则：" class="headerlink" title="设计模式的六大原则："></a>设计模式的六大原则：</h2><ol>
<li>开闭原则：对扩展开放，对修改关闭。为了程序可扩展. 易于维护和升级，需要使用接口和抽象类。</li>
<li>里氏替换原则：任何基类出现的地方，子类一定可以出现。</li>
<li>依赖反转原则：针对接口编程，依赖抽象，不依赖具体。</li>
<li>接口隔离原则：使用多个隔离的接口，比使用单个接口要好。</li>
<li>迪米特法则（最少知道原则）：一个实体应该尽量少的和其他实体之间发生交互。</li>
<li>合成复用原则：尽量使用聚合，合成方式，而不是使用继承。</li>
</ol>
<h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><ol>
<li>创建型模式：工厂模式. 抽象工厂模式. 单例模式. 建造者模式，原型模式。</li>
<li>结构型模式：适配器. 装饰器. 代理. 外观. 桥接. 组合. 享元模式</li>
<li>行为型模式：策略模式. 模板方法. 观察者模式. 迭代子模式. 责任链模式. 命令模式. 备忘录模式. 状态模式. 访问者模式. 中介模式. 解析器模式。</li>
<li>其他2种：并发型模式. 线程池模式。</li>
</ol>
<h2 id="常见设计模式："><a href="#常见设计模式：" class="headerlink" title="常见设计模式："></a>常见设计模式：</h2><ol>
<li>策略模式：定义了一系列算法，并将每个算法封装起来，使他们可以互相替换，且算法的变化不会影响到使用算法的客户。需要设计一个接口，为<br>一系列实现类提供方法，多个实现类实现该接口。</li>
<li>模板方法：准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式展现，然后声明一些抽象方法来迫使子类实现剩余逻辑。不同的子类可以以不同<br>的逻辑来实现。</li>
<li>工厂方法：建立一个工厂类，对实现了同一个接口的一些类做实例化。</li>
<li>适配器模式：适配器模式将某个类的接口转换成希望的另外一个接口表示，目的是为了消除由于接口不匹配造成的兼容性问题。主要包括三类，类的适配器.<br>对象的适配模式. 接口的适配模式。<br>类的适配器：有一个Source类，拥有一个方法，待适配，目标接口是Targetable，通过Adapter类，将Source的功能扩展到Targetable里。<br>对象的适配器：基本思路和类的适配器模式相同，只是将Adapter类作修改，这次不继承Source类，而是持有Source类的实例，以达到解决兼容性的问题。<br>接口的适配器：有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，<br>有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，<br>只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行</li>
<li>装饰模式：装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例</li>
<li>代理模式：代理模式就是多一个代理类出来，替原对象进行一些操作</li>
</ol>
<h2 id="面向对象的五大基本原则-solid"><a href="#面向对象的五大基本原则-solid" class="headerlink" title="面向对象的五大基本原则(solid)"></a>面向对象的五大基本原则(solid)</h2><ol>
<li>S单一职责SRP:Single-Responsibility Principle 一个类,最好只做一件事,只有一个引起它的变化。单一职责原则可以看做是低耦合,高内聚在面向对象原则的引申,将职责定义为引起变化的原因,以提高内聚性减少引起变化的原因。</li>
<li>O开放封闭原则OCP:Open-Closed Principle 软件实体应该是可扩展的,而不是可修改的。对扩展开放,对修改封闭</li>
<li>L里氏替换原则LSP:Liskov-Substitution Principle 子类必须能够替换其基类。这一思想表现为对继承机制的约束规范,只有子类能够替换其基类时,才能够保证系统在运行期内识别子类,这是保证继承复用的基础。</li>
<li>I接口隔离原则ISP:Interface-Segregation Principle 使用多个小的接口,而不是一个大的总接口</li>
<li>D依赖倒置原则DIP:Dependency-Inversion Principle 依赖于抽象。具体而言就是高层模块不依赖于底层模块,二者共同依赖于抽象。抽象不依赖于具体,具体依赖于抽象。</li>
</ol>
<h1 id="EasyCoding"><a href="#EasyCoding" class="headerlink" title="EasyCoding"></a>EasyCoding</h1><h2 id="Cpu与内存"><a href="#Cpu与内存" class="headerlink" title="Cpu与内存"></a>Cpu与内存</h2><ol>
<li>Cpu是一块超大规模集成电路板，是计算机的核心部件。CPU包括：控制器. 运算器. 寄存器；</li>
<li>控制器组成：控制单元. 指令译码器. 指令寄存器组成；控制单元是CPU的大脑，由时序控制器和指令控制器组成；指令译码器是在控制单元的协调下完成指令读取，<br>分析并交由运算器执行；指令寄存器是存成指令集，当前流行的指令集包括：X86，SSE，MMX等。</li>
<li>运算器：核心是算术逻辑运算单元，ALU，能执行算术运算或逻辑运算等各种指令。运算单元会从寄存器中提取或者存储数据。</li>
<li>寄存器：最著名的寄存器是CPU的高速缓存L1. L2，缓存容量是在组装计算机逼问的CPU性能问题之一；CPU缓存部分指令和数据，以提升性能；</li>
<li>L0寄存器. L1一级缓存. L2二级缓存. 内存. 本地磁盘. 分布式存储. 云端存储；</li>
</ol>
<h2 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP. IP协议"></a>TCP. IP协议</h2><ol>
<li>传输控制协议&#x2F;因特网互联协议。是当前流行的网络传输协议框架。</li>
<li>OSI模型：物理层. 数据链路层. 网络层. 传输层. 会话层. 表示层. 应用层；</li>
</ol>
<h2 id="影响RPC性能的因素如下："><a href="#影响RPC性能的因素如下：" class="headerlink" title="影响RPC性能的因素如下："></a>影响RPC性能的因素如下：</h2><ol>
<li>序列化。常用的RPC序列化协议包括：Thrift. Protobuf. Avro. Kryo. MsgPack. Hessian. Jackson。</li>
<li>传输协议。常用的传输协议包括：HTTP. Socket. TCP. UDP等；</li>
<li>连接。连接包括：长连接. 短链接；</li>
<li>IO模型。常用的网络IO模型：同步阻塞IO. 同步非阻塞IO. IO多路复用. 异步IO；<br>注释：stub一般翻译成存根，即在本地存在一个和远程一样的方法；</li>
</ol>
<h2 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h2><p>protobuf是一个高性能. 易扩展的序列化框架，通常是rpc调用追求高性能的首选。结合Netty可以非常便捷的实现RPC调用。Protobuf比JSON. XML更快. 更轻. 更小<br>，并且可以跨平台。Protobuf首先要编写proto文件，即IDL文件，后缀为“.proto”的文件。然后通过客户端生成Java相关类进行序列化. 反序列化。</p>
<h2 id="Rest"><a href="#Rest" class="headerlink" title="Rest"></a>Rest</h2><p>Rest是Representaitional State Transfer的缩写，通常翻译成“表现层状态转换”；</p>
<ol>
<li>协议：API基于HTTP协议；</li>
<li>域名：需要一个域名例如：<a target="_blank" rel="noopener" href="http://api.xx.com/">http://api.xx.com</a>;</li>
<li>版本：需要版本信息，例如<a target="_blank" rel="noopener" href="http://api.xx.com/v1/">http://api.xx.com/v1/</a></li>
<li>路径：rest开发又被称作是面向资源的开发。例如<a target="_blank" rel="noopener" href="http://api.xx.com/v1/user/">http://api.xx.com/v1/user/</a></li>
<li>方法：一般包含的方法包括：get（获取资源，一个或者多个）；post（创建资源）；put（修改资源，客户端提供修改后的完整资源）；<br>patch（对已知资源进行全局更新，客户端需要提供改变的属性）；delete（删除，回收资源）；head（获取资源的元数据）；option（读取对资源的访问权限）；<br>注释：SLA：需要提供相应时间. 吞吐量. 可用性等关键指标；</li>
</ol>
<h2 id="HTTP-x2F-2协议"><a href="#HTTP-x2F-2协议" class="headerlink" title="HTTP&#x2F;2协议"></a>HTTP&#x2F;2协议</h2><p>HTTP&#x2F;2对比HTTP&#x2F;1.x进行了大量简化，使得性能大幅提升；HTTP&#x2F;2是基于二进制协议的。<br>HTTP&#x2F;1.x的语义只支持客户端发起请求，服务端响应数据。HTTP&#x2F;2改变了这种模式，只需要客户端发送一次请求，服务端便把所有的资源都推送到客户端。</p>
<h2 id="Cloud-Native属性总结"><a href="#Cloud-Native属性总结" class="headerlink" title="Cloud Native属性总结"></a>Cloud Native属性总结</h2><p>分布式. 弹性. 多租户. 自服务. 按需计量和计费. 增量部署和测试；</p>
<h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h2><ol>
<li>gRPC默认使用Protobuf进行序列化和反序列化。</li>
<li>gRPC默认采用HTTP&#x2F;2进行传输。HTTP&#x2F;2支持流（streaming），在批量发送数据的场景下使用流可以显著提升性能；</li>
<li>gRPC流可以分为三类：客户端流式发送. 服务端流式返回. 客户端&#x2F;服务端同时流式处理；</li>
<li>gRPC并非完美，相比非IDL描述的RPC（Hession. Kyro）方式，定义proto文件是一个比较麻烦的事情。另外HTTP&#x2F;2相比于基于TCP的通信协议，心梗也有显著的差异；</li>
</ol>
<h2 id="微服务框架"><a href="#微服务框架" class="headerlink" title="微服务框架"></a>微服务框架</h2><p>服务治理. 容量规划. 高效通信（需要微服务框架实现高效的序列化. 反序列化. 支持并行. 异步. 非阻塞转换以及多语言支持）. 负载均衡（微服务框架需要支持常用<br>负载均衡. 故障转移. 支持自由的流量切换）；</p>
<h2 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h2><ol>
<li>Dubbot中的角色：Provider提供者，Consumer消费者. Registry注册中心. Montiro监控中心。</li>
<li>消费者启动后，会查询注册中心，注册中心返回提供者地址列表给消费者。如果有变更，注册中心将以长连接推送变更数据给消费者。</li>
</ol>
<h2 id="Etcd"><a href="#Etcd" class="headerlink" title="Etcd"></a>Etcd</h2><p>Etcd是一个高可用的键值存储系统，主要用于共享配置和服务发现。它使用Go语言编写，并通过Raft一致性算法处理日志复制以保障强一致性。Etcd并不是强一致的。</p>
<h2 id="微服务部署策略"><a href="#微服务部署策略" class="headerlink" title="微服务部署策略"></a>微服务部署策略</h2><p>服务独享数据库. 服务独享虚拟机&#x2F;容器；</p>
<h2 id="容器VS虚拟机"><a href="#容器VS虚拟机" class="headerlink" title="容器VS虚拟机"></a>容器VS虚拟机</h2><p>虚拟机是在硬件的基础上进行虚拟化，隔离性更高，而容器是在操作系统上进行的虚拟化。容器更像软件中的集装箱，能够把环境. 配置. 依赖. 软件等封装起来。<br>Docker可以让开发者大宝应用及依赖包到一个轻量级. 可移植的容器中，然后发布到任何安装了Docker的物理机或者虚拟机上，而不必担心是否安装了依赖项，<br>不必考虑编译器或其他任何需要支持的基础设施；</p>
<h2 id="分布式消息中间件"><a href="#分布式消息中间件" class="headerlink" title="分布式消息中间件"></a>分布式消息中间件</h2><p>通过分布式消息中间件解耦。系统之间可以进行可靠的异步通信，从而降低系统之间的耦合度，系统能够得到更好的扩展性和可用性。通过分布式消息中间件降低响应<br>时间。通过分布式消息中间件提升吞吐率。</p>
<h2 id="Kafka的设计原理"><a href="#Kafka的设计原理" class="headerlink" title="Kafka的设计原理"></a>Kafka的设计原理</h2><p>在Kafka中，消息被持久化到磁盘，Kafka需要依赖于ZooKeeper管理元数据。<br>Borker：Kafka的服务端，负责接收数据，并持久化数据，Broker可以有多个，每隔Broker可以包含多个Topic，Broker并不保存Offset数据，由Consumer自己<br>负责保存，默认保存在Zookeeper中。<br>Producer：生产者，生成数据发送到Broker存储数据，Producer将会和Topic下所有Partition Leader保持连接。<br>Consumer：消费者，每个Partition只能被一个消费者订阅，一个消费者可以订阅多个Partition，消费者挂掉后会从新进行负载均衡。<br>Topic：主题，每个Topic包含多个Partition，所有的元数据都存储在ZooKeeper中。<br>Partition：分区，Kafka为了扩展性，可以将一个Topic拆分为多个分区，每个分区可以独立放到一个Broker上。</p>
<h1 id="generic"><a href="#generic" class="headerlink" title="generic"></a>generic</h1><h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h2><ol>
<li>泛型是参数化类型，使用广泛的类型。</li>
<li>起因：数据类型不明确，装入的类型被当做Object对待，从而”丢失”自己的实际类型。获取数据的时候往往需要转型，效率低，容易产生错误。</li>
<li>作用：3.1安全，在编译的时候检查类型安全。3.2省心，所有强制类型转换都是自动和隐式的，提高代码的重用率。</li>
</ol>
<h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>class 类名 &lt;字母列表&gt; {<br>    修饰符 字母 属性<br>    修饰符 构造器{<br>    }<br>    修饰符 返回类型 方法(){<br>    }<br>}<br>泛型常见的字母列表：<br>T type 表示类型<br>K V 分别表示键中的key 和 value的值。<br>E 代表Element<br>？ 代表不确定的类型</p>
<h2 id="泛型使用需注意问题："><a href="#泛型使用需注意问题：" class="headerlink" title="泛型使用需注意问题："></a>泛型使用需注意问题：</h2><ol>
<li>不能用在静态属性. 静态方法上</li>
<li>泛型使用不能指定基本类型</li>
<li>接口中泛型只能使用在接口方法中，不能使用在全局变量中</li>
</ol>
<h1 id="http"><a href="#http" class="headerlink" title="http"></a>http</h1><h2 id="HTTP协议特点："><a href="#HTTP协议特点：" class="headerlink" title="HTTP协议特点："></a>HTTP协议特点：</h2><ol>
<li>支持客户端和服务端</li>
<li>简单：客户向服务器发送请求时，只需要传送请求方法和路径。</li>
<li>灵活：HTTP允许传输任意类型的数据对象</li>
<li>无连接：无连接限制每次连接只处理一次请求。服务器处理完客户的请求后，并收到客户的应答后，立即断开连接，采用这种方式节省时间</li>
<li>无状态：HTTP协议时无状态的，对于事务处理没有记忆能力，缺少状态意味着如果后续处理需要前面的信息，则必须重传</li>
</ol>
<h2 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h2><ol>
<li>Cookie数据存放到客户端的浏览器上，sessions数据存放在服务器上。</li>
<li>cookie不是很安全，别人可以分析本地的cookie并进行cookie欺骗。</li>
<li>单个cookie保存的数据不能超过4k，很多浏览器限制一个站点最多保存20个cookie</li>
<li>Cookie 客户端需要每次将Cookie的值传送给服务端，如果Cookie的值很大，无形中增加了客户端与服务端数据传输的数量</li>
<li>Session 同一个客户端和服务端交互，不需要每次都回传所有的cookie值，而是只需要传递一个JssionId</li>
</ol>
<h2 id="HTTP介绍"><a href="#HTTP介绍" class="headerlink" title="HTTP介绍"></a>HTTP介绍</h2><ol>
<li>大多数传统的c&#x2F;s互联网应用采用长连接方式</li>
<li>http采用无状态的端连接，采用这种方式的目的是未来同时服务更多的用户。</li>
<li>互联网所有的资源都需要用一个URL标识，URL是统一资源定位符</li>
<li>发起一个HTTP请求就是建立一个Socket的过程。</li>
<li>Http Header是控制着互联网用户数据的传输，控制着浏览器的渲染行为和服务器的执行逻辑。</li>
<li>http请求头，包括accept-charset 指定客户端接受的字符集。Accept-Encoding 用于接受可接受的内容编码。Accept-Language，<br>用于指定一种自然语言。</li>
</ol>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><ol>
<li>将域名解析成IP</li>
<li>DNS解析过程<br>2.1 检查缓存中是否有域名对应的IP，如果有直接使用，缓存大小，缓存时间都有限制。缓存时间太长一旦域名对应的IP有变化，这段时间会有部分用户无法访问。<br>时间太短，每次访问都需要重新解析。<br>2.2 如果浏览器没有缓存，操作系统也可以存储。windows在host中存储，linux在etc&#x2F;host中存储。</li>
<li>几种域名解析方式<br>3.1：A记录，A代表Address，用来指定域名对应的IP地址。A记录可以将多个域名解析到一个IP地址。但是不能将多个域名解析到多个IP地址。<br>3.2：CNAME记录，全称（别名解析），所谓的别名解析就是将一个域名设置一个或者多个别名。</li>
</ol>
<h2 id="Http和Https的区别"><a href="#Http和Https的区别" class="headerlink" title="Http和Https的区别"></a>Http和Https的区别</h2><ol>
<li>Https即Secure Hypertext Transfer Protocol，即安全超文本传输协议，它是一个安全通信信道，基于Http开发，用于在客户机和服务器间交换信息。它使用安全套接字层SSL进行信息交换，是Http的安全版。</li>
<li>Https协议需要到CA申请证书，一般免费证书很少，需要交费。</li>
<li>Http是超文本传输协议，信息是明文传输，https则是具有安全性的tls&#x2F;ssl加密传输协议。</li>
<li>http是80端口，https是443端口</li>
</ol>
<h2 id="浏览器输入一个URL的过程"><a href="#浏览器输入一个URL的过程" class="headerlink" title="浏览器输入一个URL的过程"></a>浏览器输入一个URL的过程</h2><ol>
<li>浏览器向DNS服务器请求解析该URL中的域名所对应的IP地址</li>
<li>解析出IP地址后，根据IP地址和默认端口80和服务器建立TCP连接</li>
<li>浏览器发出Http请求，该请求报文作为TCP三次握手的第三个报文的数据发送给服务器</li>
<li>服务器做出响应，把对应的请求资源发送给浏览器</li>
<li>释放TCP连接</li>
<li>浏览器解析并显示内容</li>
</ol>
<h2 id="LinuxIO模型"><a href="#LinuxIO模型" class="headerlink" title="LinuxIO模型"></a>LinuxIO模型</h2><ol>
<li>阻塞IO模型 以socket为例，在进程空间调用recvfrom，其系统调用知道数据包到达且被复制到应用进程的缓冲区或者发生错误才返回，在此期间一直等待，进程从调用recvfrom开始到它返回的整段时间内都是被阻塞的，因此称为阻塞IO</li>
<li>非阻塞IO模型 应用进程调用recvfrom，如果缓冲区没有数据直接返回EWOULDBLOCK错误。一般对非阻塞IO进行轮询，以确定是否有数据到来。</li>
<li>IO多路复用模型<br>Linux提供select&#x2F;poll，通过将一个或多个fd传递给select或poll系统调用，阻塞在select上。select&#x2F;poll顺序扫描fd是否就绪。</li>
<li>信号驱动IO<br>开启套接字接口信号驱动IO功能，并通过系统调用sigaction执行信号处理函数。当数据准备就绪时，为该进程生成SIGIO信号，通过信号回调通知应用程序调用recvfrom来读取数据，并通知主函数处理数据。</li>
<li>异步IO<br>告知内核启动某个操作，并让内核在整个操作完成后通知我们。它与信号驱动IO的区别在于信号驱动IO由内核通知我们何时可以开始IO操作。而异步IO模型由内核通知我们IO操作已经完成。</li>
</ol>
<h1 id="instrumentation"><a href="#instrumentation" class="headerlink" title="instrumentation"></a>instrumentation</h1><h2 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a>Instrumentation</h2><p>Instrumentation类为JVM上运行时的程序提供测量手段。很多工具通过Instrumentation修改方法字节码，实现数据收集的目的。<br>这些通过Instrumentation搜集数据的工具不会改变程序的状态和行为。这些良好的工作包括，monitoring agents, profilers, coverage analyzers, 和event loggers。</p>
<h2 id="获取Instrumentation接口的方式"><a href="#获取Instrumentation接口的方式" class="headerlink" title="获取Instrumentation接口的方式"></a>获取Instrumentation接口的方式</h2><ol>
<li>启动JVM时指定agent类，这种方式，instrumentation的实例通过agent class的premain方法被传入。</li>
<li>JVM提供了一种当JVM启动完成后启动agent机制，这种情况下，Instrumentation通过agent代码中的agentmain方式传入。<br>java agent 在JDK package specification中解释：一个agent 是被作为Jar 文件形式来部署的。在Jar文件中manifest中指定哪个类作为agent类。</li>
</ol>
<h1 id="Interview"><a href="#Interview" class="headerlink" title="Interview"></a>Interview</h1><h2 id="导致服务器频繁fullGC的原因有那些？"><a href="#导致服务器频繁fullGC的原因有那些？" class="headerlink" title="导致服务器频繁fullGC的原因有那些？"></a>导致服务器频繁fullGC的原因有那些？</h2><h2 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h2><ol>
<li>在高并发的系统中，缓存. 降级. 限流是三把利器。</li>
<li>限流就是限制流量，很好的控制系统的qps，从而达到保护系统的作用。</li>
<li>限流的方法<br>1）计数器：计数器是最简单最容易实现的算法。设置一个计数器counter，没当一个请求过来的时候，counter加1，如果counter的值大于100，并且<br>请求与第一个请求的间隔时间在1分钟以内，那么说明请求数过多。算法简单，最容易出现的是临界值问题。<br>2）滑动窗口：滑动窗口为了解决临界值问题，很多个矩形框组成时间窗口，每个时间窗口是1分钟，将滑动窗口划分为6个格子，每个格代表10秒钟，没过<br>10秒钟，格子向右滑动一格，每个各自有自己的counter。滑动窗口划分的格子越多，滑动窗口的滚动就越平滑，限流的统计就越精确。</li>
</ol>
<p>滑动窗口指收发两端分别维护一个发送窗口和接收窗口，发送窗口有一个窗口值Wt，窗口值Wt代表在没有收到对方确认的情况下最多可以发送的帧的数目。<br>当发送的帧的序号被接收窗口正确收下后，接收端向前滑动并向发送端发去确认，发送端收到确认后，发送窗口向前滑动。收发两端按规律向前推进.<br>滑动窗口指接收和发送两端的窗口按规律不断向前推进，是一种流量控制的策略.</p>
<p>3）漏桶算法：有个固定容量的桶，有水流进来，也有水流出去，对于进来的水，无法估量有多少，水流的速度也无法估计，但是对于流出去的水来说，可以固定流出的频率。而且<br>当桶满后，多余的水会流出去。<br>我们将算法中的水换成实际应用中的请求，我们可以看到漏桶算法天生就限制了请求的速度。当使用了漏桶算法，我们可以保证接口会以一个常速速率来处理请求。所以漏桶算法天生不会出现临界问题。<br>4）令牌桶算法：令牌桶算法比漏桶算法稍显复杂。首先，我们有一个固定容量的桶，桶里存放着令牌（token）。桶一开始是空的，token以 一个固定的速率r往桶里填充，直到达到桶的容量，多余的令牌将会被丢弃。<br>每当一个请求过来时，就会尝试从桶里移除一个令牌，如果没有令牌的话，请求无法通过。<br>我们会发现我们默认从桶里移除令牌是不需要耗费时间的。如果给移除令牌设置一个延时时间，那么实际上又采用了漏桶算法的思路。Google的guava库下的SmoothWarmingUp类就采用了这个思路。</p>
<p>Java实现<br>我们可以使用Guava 的 RateLimiter 来实现基于令牌桶的流控，RateLimiter 令牌桶算法是单桶实现。RateLimiter 对简单的令牌桶算法做了一些工程上的优化，具体的实现是 SmoothBursty。<br>需要注意的是，RateLimiter 的另一个实现SmoothWarmingUp，就不是令牌桶了，而是漏桶算法。也许是出于简单起见，RateLimiter 中的时间窗口能且仅能为 1s。<br>SmoothBursty 有一个可以放 N 个时间窗口产生的令牌的桶，系统空闲的时候令牌就一直攒着，最好情况下可以扛 N 倍于限流值的高峰而不影响后续请求。<br>RateLimite允许某次请求拿走超出剩余令牌数的令牌，但是下一次请求将为此付出代价，一直等到令牌亏空补上，并且桶中有足够本次请求使用的令牌为止。<br>当某次请求不能得到所需要的令牌时，这时涉及到一个权衡，是让前一次请求干等到令牌够用才走掉呢，还是让它先走掉后面的请求等一等呢？Guava 的设计者选择的是后者，先把眼前的活干了，后面的事后面再说。</p>
<h2 id="线程池排队策略"><a href="#线程池排队策略" class="headerlink" title="线程池排队策略"></a>线程池排队策略</h2><ol>
<li>直接提交：工作队列的默认选项是 SynchronousQueue，它将任务直接提交给线程而不保持它们。直接提交通常要求无界 maximumPoolSizes 以避免拒绝新提交的任务。<br>当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。</li>
<li>无界队列：使用无界队列（例如，不具有预定义容量的 LinkedBlockingQueue）将导致在所有 corePoolSize 线程都忙时新任务在队列中等待。这样，创建的线程就不会超过 corePoolSize。<br>（因此，maximumPoolSize 的值也就无效了。）当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；</li>
<li>有界队列：有界队列。当使用有限的 maximumPoolSizes 时，有界队列（如 ArrayBlockingQueue）有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：<br>使用大型队列和小型池可以最大限度地降低 CPU 使用率. 操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。<br>四种预定义的处理程序策略:<br>在默认的 ThreadPoolExecutor.AbortPolicy 中，处理程序遭到拒绝将抛出运行时RejectedExecutionException。<br>在 ThreadPoolExecutor.CallerRunsPolicy 中，线程调用运行该任务的execute 本身。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。<br>在 ThreadPoolExecutor.DiscardPolicy 中，不能执行的任务将被删除。<br>在 ThreadPoolExecutor.DiscardOldestPolicy 中，如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序（如果再次失败，则重复此过程）。</li>
</ol>
<ul>
<li>除了kv类型的数据存储外，redis适合的业务场景</li>
<li>如果解决写操作跨库的数据一致性问题</li>
<li>spring aop如何实现，两种的区别，描述一下java动态代理的实现</li>
<li>什么是乐观锁，乐观锁的机制是什么，<br>乐观锁实现的机制就是CAS操作</li>
</ul>
<h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><p>线程间通信和同步的方式主要有锁. 信号. 信号量<br>进程间的通信：通信机制主要有：管道. 有名管道. 消息队列. 信号量. 共享空间. 信号. 套接字（socket）<br>java线程通信 wait. notify. notifyAll. concurrent包lock下的condition里的await. signal. signalALl方法</p>
<h1 id="io"><a href="#io" class="headerlink" title="io"></a>io</h1><h2 id="字节流："><a href="#字节流：" class="headerlink" title="字节流："></a>字节流：</h2><ol>
<li>字节流可以处理一切（文本. 音频. 视频）</li>
<li>输入流 InputStream FileInputStream ByteArrayInputStream ObjectInputStream BufferedInputStream FilterInputStream DataInputStream</li>
<li>操作read字节数组<br>中间容器 byte[] flush &#x3D; new byte[长度]，接收长度 int len &#x3D; 0，循环读取while(-1!&#x3D;(len&#x3D;流.read(flush)))。输出拷贝</li>
<li>输出流 OutputStream FileOutputStream ByteArrayOutputStream ObjectOutputStream BufferedOutputStream DataOutputStream</li>
<li>操作write(字节数组,0,长度)</li>
</ol>
<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><ol>
<li>字符流，只能处理纯文本</li>
<li>输入流 Reader FileReader</li>
<li>操作read（字符数组）</li>
<li>中间容器 byte[] flush &#x3D; new byte[长度]，接收长度 int len &#x3D; 0，循环读取while(-1!&#x3D;(len&#x3D;流.read(flush)))。输出拷贝</li>
<li>输出流：Writer FileWriter</li>
<li>操作write(字节数组,0,长度)</li>
</ol>
<h2 id="字节流和字符流转换"><a href="#字节流和字符流转换" class="headerlink" title="字节流和字符流转换"></a>字节流和字符流转换</h2><ol>
<li>输入流 InputStreamReader 解码</li>
<li>输出流 OutputStreamWriter 编码</li>
</ol>
<h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><ol>
<li>输入流：BufferedInputStream BufferedReader</li>
<li>输出流：BufferedOutputStream BufferedWriter</li>
</ol>
<h2 id="处理数据-类型"><a href="#处理数据-类型" class="headerlink" title="处理数据+类型"></a>处理数据+类型</h2><ol>
<li>输入流：DataInputStream readXxx</li>
<li>输出流：DataOutputStream writeXxx</li>
<li>引用类型<br>3.1 反序列化 ObjectInputStream readObject<br>3.2 序列化 ObjectOutputStream wirteObject</li>
</ol>
<h2 id="打印流：PrintStream"><a href="#打印流：PrintStream" class="headerlink" title="打印流：PrintStream"></a>打印流：PrintStream</h2><h2 id="IO流分类"><a href="#IO流分类" class="headerlink" title="IO流分类"></a>IO流分类</h2><ol>
<li>基于字节操作的IO接口：InputStream. OutputStream</li>
<li>基于字符操作的IO接口：Reader. Writer</li>
<li>基于磁盘操作的IO接口：File</li>
<li>基于网络操作的IO接口：Socket</li>
</ol>
<h2 id="字节和字符转换"><a href="#字节和字符转换" class="headerlink" title="字节和字符转换"></a>字节和字符转换</h2><ol>
<li>InputStreamReader：从字节流转换成字符流，转换是需要指定编码格式，否则很容易出现乱码，StreamDecoder正是完成字节到字符的解码实现类。</li>
<li>OutputStreamWriter：从字符流转换成字节流，由StreamEncoder完成编码过程。</li>
</ol>
<h2 id="磁盘IO工作机制："><a href="#磁盘IO工作机制：" class="headerlink" title="磁盘IO工作机制："></a>磁盘IO工作机制：</h2><p>9.1几种访问文件的方式：</p>
<ol>
<li>标准访问文件方式：<br>read接口，首先读取用户地址空间的缓存是否存在，如果存在直接返回，如果不存在，读取内核空间的高速页缓存，如果没有则读取磁盘空间。<br>write接口，首先将数据从用户地址空间复制到内核地址空间的缓存中，这时对用户来说操作已经完成，至于什么时候写入磁盘由操作系统决定，也可以调用sync同步完成。</li>
<li>直接IO访问方式：就是应用程序直接访问磁盘，不经过操作系统内核数据缓存区，目的为了减少一次从内核缓冲区到用户缓冲区数据的复制。例如数据库管理系统。操作系统很难知道哪些是热点数据，操作系统<br>只是简单的缓存最近一次从磁盘读取的数据。直接IO访问数据，如果不在应用程序缓存中，那么每次直接从磁盘加载，会非常慢。<br>read接口：首先读取用户地址空间的缓存，如果有直接返回，没有则直接访问磁盘空间。<br>write接口：首先写入应用地址空间的缓存，然后再写入磁盘空间。</li>
<li>同步访问文件方式：同步访问文件的方式就是数据的读取和写入都是同步操作的，与标准访问文件方式不同的是，只有当数据被成功写入到磁盘时，才返回给应用程序成功的标识。<br>这种访问方式性能比较差，只有在一些对数据安全要求比较高的场景才使用。</li>
<li>异步访问文件方式：当访问数据的线程发出请求后，线程会继续处理其他事情，而不是阻塞等待，当请求的数据返回后继续处理下面的操作。这种访问方式明显提高应用程序的效率，但是不会改变访问文件的效率。</li>
<li>内存映射的方式：内存映射是操作系统将内存中的某一个区域与磁盘中的文件关联起来，当要访问内存中的一段数据时，转换成访问文件的某一段数据，这种方式的目的是同样减少数据从内核空间缓存到用户空间的数据<br>复制操作，因为这两个空间的数据是共享的。<br>9.2java访问磁盘文件：<br>java中通常的File并不代表是一个真是存在的文件对象，当你指定一个路径描述符时，它就会返回一个代表这个路径的虚拟对象，可能是一个真是存在的文件或者是一个包含多个文件的目录。FileDescriptor对象，就是<br>真正代表一个存在文件对象的描述。<br>9.3 JAVA序列化：</li>
<li>概念：将一个对象转换成一串二进制表示的字节数组，通过保存或者转意这些字节数据来达到持久化的目的，需要持久化就必须实现java.io.Serializable接口。反序列化时，必须有原始类作为模板，才能将对象还原。</li>
<li>java序列化的一些总结<br>2.1:当父类序列化时，所有子类都可以被序列化。<br>2.2:子类实现Serializable接口，父类没有，父类中的属性不会序列化（不报错，数据会丢失）<br>2.3：如果序列化的属性是对象，则这个对象必须实现Serializable接口，否则会报错。<br>2.4：在反序列化是，如果对象的属性有修改或者删除，则修改的部分属性会丢失，但是不会报错。<br>2.5：在反序列化时，如果serialVersionUID被修改，那么反序列化时会失败。</li>
</ol>
<h2 id="影响网络传输的因素："><a href="#影响网络传输的因素：" class="headerlink" title="影响网络传输的因素："></a>影响网络传输的因素：</h2><ol>
<li>网络带宽：一条物理链路上在1s内能够传输的最大比特数。</li>
<li>传输距离：也就是数据在光纤中要走的距离，数据在光纤中移动并不是直线，所以有一个折射率，大概是光的2&#x2F;3，这段时间也就是我们常说的网络延迟。</li>
<li>TCP拥塞控制：</li>
</ol>
<h2 id="BIO-NIO-AIO"><a href="#BIO-NIO-AIO" class="headerlink" title="BIO. NIO. AIO"></a>BIO. NIO. AIO</h2><ol>
<li>IO的方式通常分为几种，同步阻塞的BIO. 同步非阻塞的NIO. 异步非阻塞的AIO</li>
<li>同步阻塞IO（JAVA BIO）：<br>同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，<br>当然可以通过线程池机制改善。</li>
<li>同步非阻塞IO(Java NIO) ：<br>同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I&#x2F;O请求时才启动一个线程进行处理。</li>
<li>异步阻塞IO（Java NIO）：<br>此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问IO是否完成，<br>那么为什么说是阻塞的呢？因为此时是通过select系统调用来完成的，而select函数本身的实现方式是阻塞的，而采用select函数有个好处就是它可以同时监听多个文件句柄（如果从UNP的角度看，select属于同步操作。<br>因为select之后，进程还需要读写数据），从而提高系统的并发性！</li>
<li>Java AIO(NIO.2)）异步非阻塞IO:<br>在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，<br>因为真正的IO读取或者写入操作已经由内核完成了。</li>
</ol>
<h2 id="BIO-NIO-AIO适用场景分析"><a href="#BIO-NIO-AIO适用场景分析" class="headerlink" title="BIO. NIO. AIO适用场景分析:"></a>BIO. NIO. AIO适用场景分析:</h2><ol>
<li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。 </li>
<li>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。 </li>
<li>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</li>
</ol>
<h1 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h1><h2 id="判断对象是否已死？"><a href="#判断对象是否已死？" class="headerlink" title="判断对象是否已死？"></a>判断对象是否已死？</h2><ol>
<li>引用计数法：给对象添加一个引用计数器，当对象被引用，加1，引用失效，减1，计数器的值为0，那么可以回收。缺陷：当2个对象相互引用时，导致2个计数器的值都不为0。</li>
<li>可达性分析：Gc roots。Gc roots包括的对象有 1 虚拟机栈中引用的对象。方法区中静态属性引用的对象，方法区中常量方法引用的对象。本地方法栈中，引用的对象。</li>
<li>引用包括，强引用. 软引用. 弱引用. 虚引用。强引用：对象被引用不能被回收。软引用：用来描述一些还有用但是并非必须的对象。当系统将要发生内存溢出的时候，将会把这些对象进行第二次回收。弱引用：弱引用用来描述非必须对系那个，但是它的强度比软引用更弱一些，被弱引用的对象只能生存到下一次垃圾搜集发生之前。无论内存是否足够都会被回收。虚引用：虚引用也被称为幽灵引用或者幻影引用，它是最弱的一种引用关系。为对象设置一个虚引用唯一的目的就是能在这个对象被回收时收到一个系统通知。</li>
</ol>
<h2 id="java的类被回收的条件："><a href="#java的类被回收的条件：" class="headerlink" title="java的类被回收的条件："></a>java的类被回收的条件：</h2><ol>
<li>该类所有的实例都已经被回收，java堆中不存在该类的任何实例。</li>
<li>加载该类的classloader已经被回收。</li>
<li>该类对应的java.lang.class对象没有任何地方被引用。</li>
</ol>
<h2 id="基本回收算法"><a href="#基本回收算法" class="headerlink" title="基本回收算法"></a>基本回收算法</h2><p>    1：引用计数：比较古老的回收算法。原理是此对象有一个引用，即增加一个技术，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为0的对象。此算法时致命的是无法处理循环引用的问题。<br>    2：标记-清除：此算法执行分为两个阶段。第一个阶段从引用根节点开始标记所有被引用的对象；第二个阶段便利整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。<br>    3：复制：此算法把内存空间划分为两个相同的区域，每次只是用其中的一个区域。垃圾回收时，便利当前使用区域，把正在使用中的对象复制到另外一个区域。此算法每次只处理正在使用中的对象，因此复制成本比较小，同事复制过去以后还能进行相应的内存整理，不过会出现碎片问题。当然，此算法的缺点也是很明显的，就是需要两倍的内存。<br>    4：标记-整理：此算法结合了“标记-清除”和”复制”两个算法的有点。也是分两个阶段，第一个阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象”压缩”到堆的其中一块，按顺序排放。此算法避免了”标记-清除”碎片问题，同时也避免了复制算法的空间问题。<br>    5：增量收集：实施垃圾回收算法，即应用进行的同时进行垃圾回收。<br>    6：分代算法：基于对象生命周期分析后得出的垃圾回收算法。把对象分为年轻代. 年老带. 持久代，对不同生命周期的对象使用不同的算法进行回收。</p>
<h2 id="SavePoint安全点和安全区"><a href="#SavePoint安全点和安全区" class="headerlink" title="SavePoint安全点和安全区"></a>SavePoint安全点和安全区</h2><ol>
<li>程序执行时并非所有的地方都能停顿下来开始GC，只有到达安全点才能停顿。SafePoint的选定既不讷讷个太少导致让GC等待时间太长，也不能过于频繁已至过分增加运行的负荷。安全点的选定基本上是已”是否具有让程序长时间执行的特征”为标准进行选定的。</li>
<li>让所有的线程到达安全的方案有2中：抢先式终端，和主动式中断。抢先式中断：不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有的线程不在安全点上，就恢复线程，让它跑到安全点。主动式中断：当GC需要中断时，仅仅简单地这只一个标识，各个线程执行时主动去轮训这个标志。发现终端标志为真时，就将自己挂起。</li>
<li>安全区：在一段代码片段中，引用关系不会发生变化，在这个区域的任意地方开始GC都是安全的。例如，有些时候是程序不执行的时候，当线程处于Sleep状态或者Blocked状态，无法响应jvm的中段请求。当线程进入安全区以后，会标识自己已经进入安全区，当jvm要发起gc时，就不用管标识自己为safe region状态的线程了。</li>
</ol>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><ol>
<li>Serial收集器<br>Serial收集器是一个单线程收集器，它在进行垃圾回收时，需要stop the world。</li>
<li>ParNew收集器<br>ParNew收集器是Serial的多线程版本。是Server模式下新生代默认的收集器，目前除了Serial收集器外只有它能与CMS收集器配合使用。</li>
<li>Parallel Scavenge收集器<br>是一款新生代收集器，它采用赋值算法，又是并行的多线程收集器。主要关注的是吞吐量。吞吐量&#x3D;用户代码执行时间&#x2F;用户代码执行时间+垃圾回收时间。Parallel Scavenge收集器提供了两个参数用于青雀控制吞吐量，分别是控制最大垃圾手机停顿时间和直接设置吞吐量大小的参数。</li>
<li>Serial Old收集器<br>Serial Old是Serial的老年代版本，同样是单线程收集器。主要作用是作为CMS收集器的备用方案。</li>
<li>Parallel Old收集器<br>Parallel Old收集器是 Parallel Scavenge的老年代版本，使用的是多线程和标记-整理算法。</li>
<li>CMS收集器<br>CMS：Concurrent Mark Sweep 收集器是一种以获取最短回收停顿时间为目的的收集器。CMS收集器是给予标记-清除算法实现的整个过程包括4个步骤：1初始标记2. 并发标记. 3. 重新标记. 4并发清除。CMS的有点是并发收集. 低停顿。</li>
<li>G1收集器<br>分代概念在G1中仍然得已保留。G1从整体来看是给予标记整理算法实现的收集器. 从局部上来看是给予复制算法实现的。G1在运作期间不会出现内存空间碎片，收集后能提供规整的可用内存。有利于程序长时间运行，分配大对象。<br>可预测的停顿，这是G1与CMS的另一大优势。降低停顿时间是G1和CMS共同关注点。G1除了追求低停顿外，还能建立可预测的停顿时间模型。能够让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾回收的时间不能超过N秒。G1跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先级列表。根据每次允许的收集时间，优先回收价值最大的Resion。G1收集器运作的步骤包括：初始标记. 并发标记. 最终标记. 筛选回收。</li>
</ol>
<h2 id="JVM中并行与并发的区别"><a href="#JVM中并行与并发的区别" class="headerlink" title="JVM中并行与并发的区别"></a>JVM中并行与并发的区别</h2><ol>
<li>并行：指多条垃圾收集线程并行狗牯脑做，但此时用户线程仍然处于等待状态。</li>
<li>并发：指用户线程与垃圾搜集线程同事执行，单不一定是并行，可能是交替执行。</li>
</ol>
<h2 id="基本回收算法-1"><a href="#基本回收算法-1" class="headerlink" title="基本回收算法"></a>基本回收算法</h2><p>    1：引用计数：比较古老的回收算法。原理是此对象有一个引用，即增加一个技术，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为0的对象。此算法时致命的是无法处理循环引用的问题。<br>    2：标记-清除：此算法执行分为两个阶段。第一个阶段从引用根节点开始标记所有被引用的对象；第二个阶段便利整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。<br>    3：复制：此算法把内存空间划分为两个相同的区域，每次只是用其中的一个区域。垃圾回收时，便利当前使用区域，把正在使用中的对象复制到另外一个区域。此算法每次只处理正在使用中的对象，因此复制成本比较小，同事复制过去以后还能进行相应的内存整理，不过会出现碎片问题。当然，此算法的缺点也是很明显的，就是需要两倍的内存。<br>    4：标记-整理：此算法结合了“标记-清除”和”复制”两个算法的有点。也是分两个阶段，第一个阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象”压缩”到堆的其中一块，按顺序排放。此算法避免了”标记-清除”碎片问题，同时也避免了复制算法的空间问题。<br>    5：增量收集：实施垃圾回收算法，即应用进行的同时进行垃圾回收。<br>    6：分代算法：基于对象生命周期分析后得出的垃圾回收算法。把对象分为年轻代. 年老带. 持久代，对不同生命周期的对象使用不同的算法进行回收。</p>
<h2 id="基于分代算法"><a href="#基于分代算法" class="headerlink" title="基于分代算法"></a>基于分代算法</h2><p>    1. 年轻代：年轻代分为三个区。一个Eden区，两个Survivor区。大部分对象都是在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这个Survivor区满时，此区的存活对象被复制到另外一个Survivor区，当这个Survivor区也满了时，会从第一个Survivor区复制过来的并且此时还存活的对象，将被复制到老年代。需要注意的是Survivor区是对称的，没有先后关系，所以同一个区中可能同时存在从Eden复制过来的对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor过来的对象。而且Survivor总有一个是空的。<br>    2. 年老代：年老代存放从年轻带存货的对象。一般来说年老代都是存放生命周期较长的对象。<br>    3. 持久代：用于存放静态文件，例如java类. 方法等。持久代对垃圾回收没有显著的影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程总新增的类。持久代大小通过-XX：MAXPermSize进行设置。</p>
<h2 id="java运行时数据区域："><a href="#java运行时数据区域：" class="headerlink" title="java运行时数据区域："></a>java运行时数据区域：</h2><ol>
<li>程序计数器：当前线程所执行的字节码的行号指示器。</li>
<li>虚拟机栈：是线程私有的，它的生命周期和线程相同，每个方法在执行的时候会创建一个栈帧，用于存储变量表. 操作数栈. 方法出口. 动态连接等。</li>
<li>本地方法区：本地方法栈是为虚拟机使用到的native方法服务。</li>
<li>堆：是java虚拟机所管理的内存中最大的一块。java堆是所有线程共享的一块内存区域，目的是为了存放对象实例。</li>
<li>方法区：方法区也是各个线程共享的一块区域，用于存储虚拟机加载的类信息. 常量. 静态变量. 即时编译后的代码等。</li>
</ol>
<h1 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h1><ul>
<li>Kafka是一个高性能. 高可用. 可持久化的，为分布式设计的消息中间件。Kafka主要包括，consumer. broker. producer。</li>
<li>每一种消息的分类叫做topic，一个消息中间可以包括多个topic。为了分布式设计，每个主题又可以分成多个分区。每个分区都是一个顺序写入<br>，且不可变的文件。每个新的消息总是追加到文件末尾。每个主题可以多个分区，每个分区又可以分布到不同的机器上，所以实现了分布式系统的功能。<br>Kafka通过zk实现注册中心，将消息生产者，消费者，消息中介元数据存储到zk上，kafka也会将分区分配到不同机器。</li>
<li>对于消息发送到哪个分区，默认是轮训调度的方式，也可以根据自己的业务场景，进行定制实现消息分区的逻辑。</li>
<li>每个分区的消费都是顺序的，但是跨分区的消息不保证顺序性。kafka的消费者提供了GroupId的功能，同时只能拥有同样的GroupId的消费者，<br>消费一个分区。消息中间件分为queue和topic两种模式，如果每个消费者拥有相同的groupId，那么这个主题就被当做为queue方式消费，因为不会<br>有消费者消费相同的消息。如果每个消费者拥有不同的GroupId，那么这个主题会被当做Topic模式消费，每个消费者都会消费一遍这个消息。</li>
<li>消息的消费者使用标准的推送push模型，将消息推送到消息中介，但是消费者不同，消费者使用拉取pull模型，主动的将消息从消息中介拉取<br>到客户端，这样消息中介不需要维护消息的状态。为了提升吞吐量可以批量拉取。</li>
<li>kafka的消息中介不会存储消息状态，而是把消费到哪里的偏移量存储到客户端，并且同步到zk，可以选择批量同步，这样可以提升吞吐量，风险<br>是如果消费者崩溃，未同步的消息偏移量将导致重复消费。系统提供了3种可能消费的传递保障方式，至多一次，至少一次，仅仅一次。至多一次，无论<br>消费者是否成功，消息不会在重新推送。至少一次，消息被消费时，如果由于网络原因导致重复消费，需要业务实现幂等性，无论消费多少次都是相同<br>的结果。仅仅一次，如果消息已经被消费，再次消费消息的时候会回滚。Kafka由于设计的理念不同，只支持至少一次。</li>
<li>kafka的存储方式，kafka直接使用磁盘进行存储，没有使用缓存，由于操作系统本身就有缓存，先将数据放入缓存，经过一定时间再刷盘。<br>Kafka最大限度的利用了操作系统的缓存，所以如果想提升kafka的性能，最好使用固态硬盘。Kafka是追加数据顺序读，不会随机读写，所以及时<br>直接使用磁盘效率也很高。如果不想丢弃消息，可以修改kafka的配置参数，每发送一条消息就同步一次磁盘，用降低性能的方式提高安全性。kafka<br>会自动清理过期的消息，默认保留1个星期。</li>
<li>kafka收到消息后会向主节点和从节点发送消息。主节点用于接收和消费消息，从节点用于同步消息，kafka的主从节点不是以服务器为粒度，而<br>是以topic主体为粒度，这样每台机器都会有主从分区，最大限度的利用了机器资源。</li>
</ul>
<h1 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h1><ol>
<li>Lock能完成几乎所有synchronized的功能，并有一些后者不具备的功能，如锁投票. 定时锁等候. 可中断锁等候等。</li>
<li>synchronized 是Java 语言层面的，是内置的关键字；Lock 则是JDK 5中出现的一个包，在使用时，synchronized 同步的代码块可以由JVM自动释放；<br>Lock 需要程序员在finally块中手工释放，如果不释放，可能会引起难以预料的后果</li>
</ol>
<h2 id="主内存和工作内存："><a href="#主内存和工作内存：" class="headerlink" title="主内存和工作内存："></a>主内存和工作内存：</h2><ol>
<li>Java内存模型中规定了所有的变量都存储在主内存中，每个线程还有自己的工作内存，线程的工作内存，保存了该线程使用到的主内存副本拷贝，线程对变量的所有操作必须在工作内存中，而不能直接读写主内存中的变量，<br>不同线程之间无法直接访问对方工作内存中的变量，线程间值的传递均需要通过主内存来完成。</li>
</ol>
<h2 id="什么是自旋锁："><a href="#什么是自旋锁：" class="headerlink" title="什么是自旋锁："></a>什么是自旋锁：</h2><p>自旋锁jdk1.6后默认自动开启，基于之前的观察，共享数据的锁定状态只会持续很短的时间，为了这一段时间而去挂起和恢复线程有点浪费，然后面请求锁的那个线程稍等一会，但是不放弃处理器的执行时间，看看只有线程的锁<br>是否能很快释放。为了让线程等待，所以需要让线程执行一个忙循环自旋操作。</p>
<h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>虚拟机即使编译器在运行时，对于代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。如果判断一段代码，在堆上的数据都不会逃逸，被其他线程访问到，那么认为是线程私有的，同步加锁也就没有必要了。</p>
<h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>原则上，在编写代码时，推荐将同步块的作用范围限制的尽量小，仅仅在共享数据的实际作用域才进行同步，这样目的是使得需要同步的操作尽可能小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。但是如果一系列的连续<br>操作都对同一个对象反复加锁和解锁，甚至锁出现在循环体内，及时没有线程竞争，频繁的进行互斥操作也会带来性能损耗。</p>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>偏向锁意思是这个锁会偏向第一个获取它的线程，如果在接下来的过程中，该锁没有被其他线程获取，则只有偏向锁的线程将永远不需要进行同步，偏向锁可以提高带有同步但是没有竞争的程序的性能。偏向锁也不一定总是对程序<br>有利的，如果程序中的锁大部分都是被多个不同的线程访问，那么偏向模式就是多余的。</p>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>轻量级锁能提升程序同步性能的依据是”对于绝大部分的锁，在整个同步周期内都是不存在竞争”，这是一个经验值。如果没有竞争，轻量级锁使用CAS操作避免了使用互斥所的开销，但如果存在竞争，除了互斥锁的开销外，还额外<br>发生了CAS操作，一次在竞争的情况下，轻量级锁会比传统重量级锁更慢。</p>
<h2 id="volatile变量"><a href="#volatile变量" class="headerlink" title="volatile变量"></a>volatile变量</h2><p>volatile能够实现可见性，但是不能保证原子性。</p>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS包括三个操作数，内存位置，预期旧值，新值。如果内存位置的值和预期的旧值相同，那么使用新值替换旧值。</p>
<h2 id="如何实现互斥同步？"><a href="#如何实现互斥同步？" class="headerlink" title="如何实现互斥同步？"></a>如何实现互斥同步？</h2><p>java中最基本的互斥就是synchronized关键字，synchronized在经过编译后，会在同步块的前后分别形成monitorenter和moitorexit这两个字节码指令。在执行monitorenter指令时，首先要去尝试获取对象的锁，<br>如果这个对象没有被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行monitorexit指令时会把锁计数器减1，当计数器为0时，锁就被释放了。如果获取对象的锁失败，当当前线程就要阻塞等待，<br>知道对象的锁被另一个线程释放为止。synchronized对于同一个线程来说是可重入的，不会出现自己把自己锁死的问题。除了synchronized指望，JUC中的Lock也能实现互斥同步，ReentrantLock，写法上更加可见，<br>lock和unlock配合try&#x2F;finally来配合完成，ReentrantLock比synchronized有几个高级的特性。</p>
<h2 id="ReentrantLock的高级特性有那几个？"><a href="#ReentrantLock的高级特性有那几个？" class="headerlink" title="ReentrantLock的高级特性有那几个？"></a>ReentrantLock的高级特性有那几个？</h2><ol>
<li>等待可中断，当持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，改为处理其他事情；</li>
<li>可以实现公平锁，公平锁指多个线程在等待同一个锁时，必须按照申请锁的顺序依次获得锁，synchronized是非公平锁，ReentrantLock默认也是非公平的，只不过可以通过构造函数来制定实现公平锁；</li>
<li>锁绑定多个条件，ReentrantLock对象可以同时绑定多个Condition对象，在synchronized中，锁对象的wait&#x2F;notify&#x2F;notifyall方法可以实现一个隐含的条件，如果要多一个条件关联的时候，就需要额外的增加一个锁；</li>
</ol>
<h2 id="关于sunchronized的几个注意点？"><a href="#关于sunchronized的几个注意点？" class="headerlink" title="关于sunchronized的几个注意点？"></a>关于sunchronized的几个注意点？</h2><ol>
<li>当一个线程访问object的一个synchronized(this)同步代码块时， 另一个线程仍然可以访问该object中的非synchronized(this)同步代码块；</li>
<li>当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时， 一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块；</li>
<li>尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时， 其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞；</li>
<li>Java中的每一个对象都可以作为锁，对于同步方法，锁是当前实例对象，对于静态同步方法，锁是当前对象的Class对象，对于同步方法块，锁是Synchonized括号里配置的对象；</li>
</ol>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">## JAVA concurrent包下的类：</span><br><span class="line">Executors</span><br><span class="line"> Executor</span><br><span class="line"> ExecutorService</span><br><span class="line"> ScheduledExecutorService</span><br><span class="line"> Callable</span><br><span class="line"> Future</span><br><span class="line"> ScheduledFuture</span><br><span class="line"> Delayed</span><br><span class="line"> CompletionService</span><br><span class="line"> ThreadPoolExecutor</span><br><span class="line"> ScheduledThreadPoolExecutor</span><br><span class="line"> AbstractExecutorService</span><br><span class="line"> Executors</span><br><span class="line"> FutureTask</span><br><span class="line"> ExecutorCompletionService</span><br><span class="line">Queues</span><br><span class="line"> BlockingQueue</span><br><span class="line"> ConcurrentLinkedQueue</span><br><span class="line"> LinkedBlockingQueue</span><br><span class="line"> ArrayBlockingQueue</span><br><span class="line"> SynchronousQueue</span><br><span class="line"> PriorityBlockingQueue</span><br><span class="line"> DelayQueue</span><br><span class="line">Concurrent Collections</span><br><span class="line"> ConcurrentMap</span><br><span class="line"> ConcurrentHashMap</span><br><span class="line"> CopyOnWriteArray&#123;List,Set</span><br><span class="line">Synchronizers</span><br><span class="line"> CountDownLatch</span><br><span class="line"> Semaphore</span><br><span class="line"> Exchanger</span><br><span class="line"> CyclicBarrier</span><br><span class="line">Timing</span><br><span class="line"> TimeUnit</span><br><span class="line">Locks</span><br><span class="line"> Lock</span><br><span class="line"> Condition</span><br><span class="line"> ReadWriteLock</span><br><span class="line"> AbstractQueuedSynchronizer</span><br><span class="line"> LockSupport</span><br><span class="line"> ReentrantLock</span><br><span class="line"> ReentrantReadWriteLock</span><br><span class="line">Atomics</span><br><span class="line"> Atomic[Type], Atomic[Type]Array</span><br><span class="line"> Atomic[Type], FieldUpdater</span><br><span class="line"> Atomic&#123;Markable, Stampable&#125;Reference&#125;</span><br></pre></td></tr></table></figure>
<h2 id="原子性-可见性-有序性"><a href="#原子性-可见性-有序性" class="headerlink" title="原子性. 可见性. 有序性"></a>原子性. 可见性. 有序性</h2><ol>
<li>原子性：由java内存模型来直接保证原子性变量操作包括：lock. unlock. read. load. assign. use. store和write 。</li>
<li>可见性：当一个线程修改了共享变量的值，其他线程能够立即知道这个修改。java内存模型是通过在变量修改后将新值同步回<br>主内存，在变量读取之前需要从主内存刷新变量值这种依赖猪内存作为传递媒介的方式来实现的可见性。除了volatitle关键字外，<br>还有2个synchronized. final。</li>
<li>有序性：java提供了volatitle和synchronized关键字来保证线程之间操作的有序性。</li>
</ol>
<h1 id="mongodb"><a href="#mongodb" class="headerlink" title="mongodb"></a>mongodb</h1><h2 id="MongoDB简介"><a href="#MongoDB简介" class="headerlink" title="MongoDB简介"></a>MongoDB简介</h2><ol>
<li>MongoDB是一个开源的. 面向文档的存储的NoSql数据库。</li>
<li>模式自由. 支持动态查询. 完全索引. 可以轻易查询文档中内嵌的对象及数组。</li>
<li>面向文档存储，易存储对象类型的数据。</li>
<li>高效的文档存储，支持二进制数据及大型对象。</li>
<li>支持复制和故障恢复</li>
<li>自动分片支持云级别的伸缩性，支持水平的数据库集群。</li>
</ol>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h2><p>高性能. 易部署. 易使用，存储数据非常方便。主要功能特性有：<br>面向集合存储，易存储对象类型的数据。<br>模式自由。<br>支持动态查询。<br>支持完全索引，包含内部对象。<br>支持查询。<br>支持复制和故障恢复。<br>使用高效的二进制数据存储，包括大型对象（如视频等）。<br>自动处理碎片，以支持云计算层次的扩展性<br>支持Python，PHP，Ruby，Java，C，C#，Javascript，Perl及C++语言的驱动程序，社区中也提供了对Erlang及.NET等平台的驱动程序。<br>文件存储格式为BSON（一种JSON的扩展）。<br>可通过网络访问。</p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能:"></a>功能:</h2><p>面向集合的存储：适合存储对象及JSON形式的数据。<br>动态查询：Mongo支持丰富的查询表达式。查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。<br>完整的索引支持：包括文档内嵌对象及数组。Mongo的查询优化器会分析查询表达式，并生成一个高效的查询计划。<br>查询监视：Mongo包含一个监视工具用于分析数据库操作的性能。<br>复制及自动故障转移：Mongo数据库支持服务器之间的数据复制，支持主-从模式及服务器之间的相互复制。复制的主要目标是提供冗余及自动故障转移。<br>高效的传统存储方式：支持二进制数据及大型对象（如照片或图片）<br>自动分片以支持云级别的伸缩性：自动分片功能支持水平的数据库集群，可动态添加额外的机器。</p>
<h2 id="适用场合"><a href="#适用场合" class="headerlink" title="适用场合:"></a>适用场合:</h2><p>网站数据：Mongo非常适合实时的插入，更新与查询，并具备网站实时数据存储所需的复制及高度伸缩性。<br>缓存：由于性能很高，Mongo也适合作为信息基础设施的缓存层。在系统重启之后，由Mongo搭建的持久化缓存层可以避免下层的数据源 过载。<br>大尺寸，低价值的数据：使用传统的关系型数据库存储一些数据时可能会比较昂贵，在此之前，很多时候程序员往往会选择传统的文件进行存储。<br>高伸缩性的场景：Mongo非常适合由数十或数百台服务器组成的数据库。Mongo的路线图中已经包含对MapReduce引擎的内置支持。<br>用于对象及JSON数据的存储：Mongo的BSON数据格式非常适合文档化格式的存储及查询。</p>
<h2 id="与传统数据库对比"><a href="#与传统数据库对比" class="headerlink" title="与传统数据库对比"></a>与传统数据库对比</h2><p>MongoDb是由数据库databse. 集合collection. 文档对象document三个层次组成。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>MongoDB提供了多样性的索引支持，索引信息被保存在sytem.indexes中，且默认为_id创建索引，它的索引使用基本和mysql一样。</p>
<h1 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h1><h2 id="Mysql主要存储引擎包括InnoDB-MyISAM"><a href="#Mysql主要存储引擎包括InnoDB-MyISAM" class="headerlink" title="Mysql主要存储引擎包括InnoDB. MyISAM"></a>Mysql主要存储引擎包括InnoDB. MyISAM</h2><h2 id="InnoDB和MyISAM的区别："><a href="#InnoDB和MyISAM的区别：" class="headerlink" title="InnoDB和MyISAM的区别："></a>InnoDB和MyISAM的区别：</h2><ol>
<li>MyISAM不支持事物，表锁，支持全文检索，不支持外键，表空间相对比较小，关注的主要是查询的性能。</li>
<li>InnoDB支持事物，行锁，不支持全文检索，支持外检，表空间相对比较大，关注的是事务。</li>
<li>MyISAM的读性能比InnoDB强。</li>
</ol>
<h2 id="数值类型："><a href="#数值类型：" class="headerlink" title="数值类型："></a>数值类型：</h2><ol>
<li>tinyint 1个字节</li>
<li>smallint 2个字节</li>
<li>mediumint 3个字节</li>
<li>int 4个字节</li>
<li>bigint 8个字节</li>
<li>float 4个字节</li>
<li>double 8个字节</li>
<li>bit 1-8个字节</li>
</ol>
<h2 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h2><ol>
<li>如果表示年月日用date</li>
<li>如果标示年月日时分秒，用datetime和timestamp</li>
<li>如果表示十分秒，用time</li>
<li>如果表示年，用year</li>
</ol>
<h2 id="datetime和timestamp的区别："><a href="#datetime和timestamp的区别：" class="headerlink" title="datetime和timestamp的区别："></a>datetime和timestamp的区别：</h2><ol>
<li>timestamp支持的时间范围比较小，从1970年到2038年的某个时间。</li>
<li>timestamp的查询和插入受当地时区的影响。</li>
</ol>
<h2 id="char-varchar-binary-varbinary-blob-text-enum和set"><a href="#char-varchar-binary-varbinary-blob-text-enum和set" class="headerlink" title="char. varchar. binary. varbinary. blob. text. enum和set"></a>char. varchar. binary. varbinary. blob. text. enum和set</h2><ol>
<li>char的固定长度是0-255，且会去掉末尾的空格</li>
<li>varchar是非固定的，会保留末尾的空格</li>
</ol>
<h2 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h2><ol>
<li>数据库隔离级别包括：读未提交. 读提交. 重复读. 序列化。</li>
<li>数据库各种隔离级别出现的问题：脏读. 不可重复度. 幻读</li>
<li>读未提交：脏读. 不可重复读. 幻读</li>
<li>读提交：不可重复读. 幻读</li>
<li>重复度：幻读</li>
<li>序列化：不会出现问题</li>
</ol>
<h2 id="各种隔离级别出现的问题"><a href="#各种隔离级别出现的问题" class="headerlink" title="各种隔离级别出现的问题"></a>各种隔离级别出现的问题</h2><ol>
<li>脏读：一个事务读取了另外一个事务未提交的数据，而这个数据有可能回滚。</li>
<li>不可重复读：在访问数据库时，一个事务范围内的两次查询，返回了不同的结果。这是由于查询时系统中其他事务修改的提交而引起的。</li>
<li>幻读：是指事务不是独立执行时发生的一种现象。，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样.</li>
</ol>
<ul>
<li><p>小数类型为 decimal,禁止使用 float 和 double。<br>说明:float 和 double 在存储的时候,存在精度损失的问题,很可能在值的比较时,得到不 正确的结果。如果存储的数据范围超过 decimal 的范围,建议将数据拆成整数和小数分开存储。</p>
</li>
<li><p>如果存储的字符串长度几乎相等,使用 char 定长字符串类型。<br>varchar 是可变长字符串,不预先分配存储空间,长度不要超过 5000,如果存储长 度大于此值,定义字段类型为 text,独立出来一张表,用主键来对应,避免影响其它字段索 引效率。</p>
</li>
<li><p>字段允许适当冗余,以提高性能,但是必须考虑数据同步的情况。冗余字段应遵循:<br>1)不是频繁修改的字段。<br>2)不是 varchar 超长字段,更不能是 text 字段。</p>
</li>
<li><p>单表行数超过 500 万行或者单表容量超过 2GB,才推荐进行分库分表。 说明:如果预计三年后的数据量根本达不到这个级别,请不要在创建表时就分库分表。</p>
</li>
<li><p>合适的字符存储长度,不但节约数据库表空间. 节约索引存储,更重要的是提升检 索速度。</p>
</li>
<li><p>业务上具有唯一特性的字段,即使是组合字段,也必须建成唯一索引。<br>说明:不要以为唯一索引影响了 insert 速度,这个速度损耗可以忽略,但提高查找速度是明 显的;另外,即使在应用层做了非常完善的校验和控制,只要没有唯一索引,根据墨菲定律, 必然有脏数据产生。</p>
</li>
<li><p>超过三个表禁止 join。需要 join 的字段,数据类型保持绝对一致;多表关联查询 时,保证被关联的字段需要有索引。<br>说明:即使双表 join 也要注意表索引. SQL 性能。</p>
</li>
<li><p>在 varchar 字段上建立索引时,必须指定索引长度,没必要对全字段建立索引,根据 实际文本区分度决定索引长度。<br>说明:索引的长度与区分度是一对矛盾体,一般对字符串类型数据,长度为 20 的索引,区分 度会高达 90%以上,可以使用 count(distinct left(列名, 索引长度))&#x2F;count(*)的区分度 来确定。</p>
</li>
<li><p>页面搜索严禁左模糊或者全模糊,如果需要请走搜索引擎来解决。 说明:索引文件具有 B-Tree 的最左前缀匹配特性,如果左边的值未确定,那么无法使用此索 引。</p>
</li>
<li><p>如果有 order by 的场景,请注意利用索引的有序性。order by 最后的字段是组合 索引的一部分,并且放在索引组合顺序的最后,避免出现 file_sort 的情况,影响查询性能。<br>正例:where a&#x3D;? and b&#x3D;? order by c; 索引:a_b_c 反例:索引中有范围查找,那么索引有序性无法利用,如:WHERE a&gt;10 ORDER BY b; 索引 a_b 无法排序。</p>
</li>
<li><p>利用覆盖索引来进行查询操作,来避免回表操作。<br>说明:如果一本书需要知道第 11 章是什么标题,会翻开第 11 章对应的那一页吗?目录浏览 一下就好,这个目录就是起到覆盖索引的作用。<br>正例:能够建立索引的种类:主键索引. 唯一索引. 普通索引,而覆盖索引是一种查询的一种 效果,用explain的结果,extra列会出现:using index</p>
</li>
<li><p>利用延迟关联或者子查询优化超多分页场景。<br>说明:MySQL 并不是跳过 offset 行,而是取 offset+N 行,然后返回放弃前 offset 行,返回 N 行,那当 offset 特别大的时候,效率就非常的低下,要么控制返回的总页数,要么对超过 特定阈值的页数进行 SQL 改写。<br>正例:先快速定位需要获取的 id 段,然后再关联:<br>SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id&#x3D;b.id</p>
</li>
<li><p>SQL 性能优化的目标:至少要达到 range 级别,要求是 ref 级别,如果可以是 consts 最好。<br>说明:<br>1)consts 单表中最多只有一个匹配行(主键或者唯一索引),在优化阶段即可读取到数据。 2)ref 指的是使用普通的索引(normal index)。<br>3)range 对索引进行范围检索。<br>反例:explain 表的结果,type&#x3D;index,索引物理文件全扫描,速度非常慢,这个 index 级 别比较 range 还低,与全表扫描是小巫见大巫。</p>
</li>
<li><p>建组合索引的时候,区分度最高的在最左边。<br>正例:如果 where a&#x3D;? and b&#x3D;? ,a 列的几乎接近于唯一值,那么只需要单建 idx_a 索引即 可。<br>说明:存在非等号和等号混合判断条件时,在建索引时,请把等号条件的列前置。如:where a&gt;? and b&#x3D;? 那么即使 a 的区分度更高,也必须把 b 放在索引的最前列。</p>
</li>
<li><p>创建索引时避免有如下极端误解:<br>1)误认为一个查询就需要建一个索引。 2)误认为索引会消耗空间. 严重拖慢更新和新增速度。 3)误认为唯一索引一律需要在应用层通过“先查后插”方式解决。</p>
</li>
<li><p>count(*)会统计值为 NULL 的行,而 count(列名)不会统计此列为 NULL 值的行</p>
</li>
<li><p>当某一列的值全是 NULL 时,count(col)的返回结果为 0,但 sum(col)的返回结果为 NULL,因此使用 sum()时需注意 NPE 问题<br>正例:可以使用如下方式来避免sum的NPE问题:SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table;</p>
</li>
<li><p>使用 ISNULL()来判断是否为 NULL 值。注意:NULL 与任何值的直接比较都为 NULL。 说明:</p>
</li>
</ul>
<ol>
<li>NULL&lt;&gt;NULL的返回结果是NULL,而不是false。 2) NULL&#x3D;NULL的返回结果是NULL,而不是true。 3) NULL&lt;&gt;1的返回结果是NULL,而不是true。</li>
</ol>
<h1 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h1><h2 id="为什么使用Netty"><a href="#为什么使用Netty" class="headerlink" title="为什么使用Netty?"></a>为什么使用Netty?</h2><ol>
<li>Netty提供了这样的一个间接的解决方法。Netty提供了高层次的抽象来简化TCP和UDP服务器的编程,但是你仍然可以使用底层地API。</li>
<li>Netty成功的提供了易于开发,高性能和高稳定性,以及较强的扩展性</li>
</ol>
<h2 id="Design-设计"><a href="#Design-设计" class="headerlink" title="Design(设计)"></a>Design(设计)</h2><p>各种传输类型,阻塞和非阻塞套接字统一的API<br>使用灵活<br>简单但功能强大的线程模型<br>无连接的DatagramSocket支持<br>链逻辑,易于重用</p>
<h2 id="Ease-of-Use-易于使-用"><a href="#Ease-of-Use-易于使-用" class="headerlink" title="Ease of Use(易于使 用)"></a>Ease of Use(易于使 用)</h2><p>提供大量的文档和例子<br>除了依赖jdk1.6+,没有额外的依赖关系。某些功能依赖jdk1.7+,其他特性可能有相 关依赖,但都是可选的。</p>
<h2 id="Performance-性能"><a href="#Performance-性能" class="headerlink" title="Performance(性能)"></a>Performance(性能)</h2><p>比Java APIS更好的吞吐量和更低的延迟<br>因为线程池和重用所有消耗较少的资源<br>尽量减少不必要的内存拷贝</p>
<h2 id="Robustness-鲁棒性"><a href="#Robustness-鲁棒性" class="headerlink" title="Robustness(鲁棒性)"></a>Robustness(鲁棒性)</h2><p>链接快或慢或超载不会导致更多的OutOfMemoryError<br>在高速的网络程序中不会有不公平的read&#x2F;write</p>
<h2 id="Security-安全性"><a href="#Security-安全性" class="headerlink" title="Security(安全性)"></a>Security(安全性)</h2><p>完整的SSL&#x2F;TLS和StartTLS支持<br>可以在如Applet或OSGI这些受限制的环境中运行</p>
<h2 id="Community-社区"><a href="#Community-社区" class="headerlink" title="Community(社区)"></a>Community(社区)</h2><p>版本发布频繁<br>社区活跃</p>
<h1 id="network"><a href="#network" class="headerlink" title="network"></a>network</h1><h2 id="Netty-解决TCP粘包-x2F-拆包问题"><a href="#Netty-解决TCP粘包-x2F-拆包问题" class="headerlink" title="Netty 解决TCP粘包&#x2F;拆包问题"></a>Netty 解决TCP粘包&#x2F;拆包问题</h2><p>业务上一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。<br>对于这类问题，netty提供了LineBasedFrameDecoder和StringDecoder进行完美解决。如下是相关代码。</p>
<ol>
<li>LineBasedFrameDecoder<br>工作原理是依次遍历ByteBuf中的可读字节，判断是否有换行符，如果有，就以此位置为结束位置，从可读索引到结束位置区间的字节就组成了一行。</li>
<li>StringDecoder<br>功能就是将接受到的对象转换为字符串，然后继续调用后面的handler。<br>LineBasedFrameDecoder+StringDecoder组合就是按行切换的文本解码器。</li>
<li>其他解码器<br>DelimiterBasedFrameDecoder可以自定义分隔符<br>FixedLengthFrameDecoder定长解码器。</li>
</ol>
<h1 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h1><h2 id="Nginx能做什么？"><a href="#Nginx能做什么？" class="headerlink" title="Nginx能做什么？"></a>Nginx能做什么？</h2><ol>
<li>反向代理</li>
<li>负载均衡</li>
<li>HTTP服务器（包含动静分离）</li>
<li>正向代理</li>
</ol>
<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>反向代理是指代理服务器接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器得到的结果返回给internet上请求连接的客户端，此时代理服务器<br>对外表现为一个反向代理服务器。简单的说就是真是的服务器不能直接被外部网络访问，需要一台代理服务器，而代理服务器能被外部网络访问的同时又跟真是服务器在同一个网络环境。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;  </span><br><span class="line">    listen       80;                                                        </span><br><span class="line">    server_name  localhost;                                              </span><br><span class="line">    client_max_body_size 1024M;</span><br><span class="line"> </span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://localhost:8080;</span><br><span class="line">        proxy_set_header Host :;</span><br><span class="line">       </span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>保存配置文件后启动Nginx，这样当我们访问localhost的时候，就相当于访问localhost:8080了</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><ol>
<li>RR 默认<br>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">upstream test &#123;</span><br><span class="line">        server localhost:8080;</span><br><span class="line">        server localhost:8081;</span><br><span class="line">    </span><br><span class="line">    server &#123;</span><br><span class="line">        listen       81;                                                        </span><br><span class="line">        server_name  localhost;                                              </span><br><span class="line">        client_max_body_size 1024M;</span><br><span class="line"> </span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://test;</span><br><span class="line">            proxy_set_header Host :;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>负载均衡的核心代码为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream test &#123;</span><br><span class="line">       server localhost:8080;</span><br><span class="line">       server localhost:8081;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里我配置了2台服务器，当然实际上是一台，只是端口不一样而已，而8081的服务器是不存在的,也就是说访问不到，但是我们访问<a target="_blank" rel="noopener" href="http://localhost/">http://localhost</a> 的时候,也不会有问题，会默认跳转到<a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080</a><br>具体是因为Nginx会自动判断服务器的状态，如果服务器处于不能访问（服务器挂了），就不会跳转到这台服务器，所以也避免了一台服务器挂了影响使用的情况，由于Nginx默认是RR策略，所以我们不需要其他更多的设置。</p>
<ol start="2">
<li>权重<br>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 例如</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">upstream test &#123;</span><br><span class="line">    server localhost:8080 weight=9;</span><br><span class="line">    server localhost:8081 weight=1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么10次一般只会有1次会访问到8081，而有9次会访问到8080</p>
<ol start="3">
<li>ip_hash<br>上面的2种方式都有一个问题，那就是下一个请求来的时候请求可能分发到另外一个服务器，当我们的程序不是无状态的时候（采用了session保存数据），这时候就有一个很大的很问题了，比如把登录信息保存到了session中，那么跳转到另外一台服务器的时候就需要重新登录了，所以很多时候我们需要一个客户只访问一个服务器，那么就需要用iphash了，iphash的每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream test &#123;</span><br><span class="line">        ip_hash;</span><br><span class="line">        server localhost:8080;</span><br><span class="line">        server localhost:8081;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>fair（第三方）<br>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">      fair;</span><br><span class="line">      server localhost:8080;</span><br><span class="line">      server localhost:8081;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>url_hash（第三方）<br>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">upstream backend &#123;</span><br><span class="line">    hash ;</span><br><span class="line">    hash_method crc32;</span><br><span class="line">    server localhost:8080;</span><br><span class="line">    server localhost:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上5种负载均衡各自适用不同情况下使用，所以可以根据实际情况选择使用哪种策略模式,不过fair和url_hash需要安装第三方模块才能使用，由于本文主要介绍Nginx能做的事情，所以Nginx安装第三方模块不会再本文介绍</p>
<h2 id="HTTP服务器"><a href="#HTTP服务器" class="headerlink" title="HTTP服务器"></a>HTTP服务器</h2><p>Nginx本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用Nginx来做服务器，同时现在也很流行动静分离，就可以通过Nginx来实现，<br>首先看看Nginx做静态资源服务器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">       listen       80;                                                        </span><br><span class="line">       server_name  localhost;                                              </span><br><span class="line">       client_max_body_size 1024M;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       location / &#123;</span><br><span class="line">              root   e:wwwroot;</span><br><span class="line">              index  index.html;</span><br><span class="line">          </span><br><span class="line">   &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>这样如果访问<a target="_blank" rel="noopener" href="http://localhost/">http://localhost</a> 就会默认访问到E盘wwwroot目录下面的index.html，如果一个网站只是静态页面的话，那么就可以通过这种方式来实现部署。</p>
<h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p>动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">upstream test&#123;  </span><br><span class="line">       server localhost:8080;  </span><br><span class="line">       server localhost:8081;  </span><br><span class="line">      </span><br><span class="line"> </span><br><span class="line">    server &#123;  </span><br><span class="line">        listen       80;  </span><br><span class="line">        server_name  localhost;  </span><br><span class="line"> </span><br><span class="line">        location / &#123;  </span><br><span class="line">            root   e:wwwroot;  </span><br><span class="line">            index  index.html;  </span><br><span class="line">        &#125;  </span><br><span class="line"> </span><br><span class="line">        # 所有静态请求都由nginx处理，存放目录为html  </span><br><span class="line">        location ~ .(gif|jpg|jpeg|png|bmp|swf|css|js)$ &#123;  </span><br><span class="line">            root    e:wwwroot;  </span><br><span class="line">        &#125;  </span><br><span class="line"> </span><br><span class="line">        # 所有动态请求都转发给tomcat处理  </span><br><span class="line">        location ~ .(jsp|do)$ &#123;  </span><br><span class="line">            proxy_pass  http://test;  </span><br><span class="line">        &#125;  </span><br><span class="line"> </span><br><span class="line">        error_page   500 502 503 504  /50x.html;  </span><br><span class="line">        location = /50x.html &#123;  </span><br><span class="line">            root   e:wwwroot;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以吧HTML以及图片和css以及js放到wwwroot目录下，而tomcat只负责处理jsp和请求，例如当我们后缀为gif的时候，<br>Nginx默认会从wwwroot获取到当前请求的动态图文件返回，当然这里的静态文件跟Nginx是同一台服务器，我们也可以在另外一台服务器，然后通过反向代理和负载均衡配置过去就好了，只要搞清楚了最基本的流程，很多配置就很简单了，另外localtion后面其实是一个正则表达式，所以非常灵活</p>
<h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p>正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。当你需要把你的服务器作为代理服务器的时候，可以用Nginx来实现正向代理，但是目前Nginx有一个问题，那么就是不支持HTTPS，虽然我百度到过配置HTTPS的正向代理，但是到最后发现还是代理不了，当然可能是我配置的不对，所以也希望有知道正确方法的同志们留言说明一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">resolver 114.114.114.114 8.8.8.8;</span><br><span class="line">server &#123;</span><br><span class="line"> </span><br><span class="line">    resolver_timeout 5s;</span><br><span class="line"> </span><br><span class="line">    listen 81;</span><br><span class="line"> </span><br><span class="line">    access_log  e:wwwrootproxy.access.log;</span><br><span class="line">    error_log   e:wwwrootproxy.error.log;</span><br><span class="line"> </span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://;</span><br><span class="line">    </span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>resolver是配置正向代理的DNS服务器，listen 是正向代理的端口，配置好了就可以在ie上面或者其他代理插件上面使用服务器ip+端口号进行代理了。</p>
<h2 id="Nginx热部署"><a href="#Nginx热部署" class="headerlink" title="Nginx热部署"></a>Nginx热部署</h2><p>Nginx是支持热启动的，也就是说当我们修改配置文件后，不用关闭Nginx，就可以实现让配置生效，当然我并不知道多少人知道这个，反正我一开始并不知道，导致经常杀死了Nginx线程再来启动。。。Nginx从新读取配置的命令是<br>nginx -s reload<br>windows下面就是<br>nginx.exe -s reload  </p>
<h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><h2 id="redis数据类型"><a href="#redis数据类型" class="headerlink" title="redis数据类型"></a>redis数据类型</h2><ol>
<li>string. list. set. zset. hash</li>
<li>String是最简单的类型，一个key对应一个value</li>
<li>list是一个链表，主要包括push. pop，获取一定范围内的所有值，操作中key为链表的名称</li>
<li>set是集合，对集合的操作包括，新增. 删除. 合并求交集等，操作中的key为集合的名称。</li>
<li>zSet是set的一个升级版本，在set的基础上增加了顺序的功能，这个属性在添加删除的时候可以指定，每次指定后，zSet会自动重新按照<br>新的值调整顺序。</li>
<li>Hash数据类型允许用户使用redis对象类型，当你存储的数据对象只有很少几个key值时，数据存储的消耗会很小。</li>
</ol>
<h2 id="Redis的持久化方式："><a href="#Redis的持久化方式：" class="headerlink" title="Redis的持久化方式："></a>Redis的持久化方式：</h2><ol>
<li>RDB方式：默认redis会以快照的形式存储数据持久化到硬盘中，在配置文件中的格式是 save N M，标识在N秒的时间内，redis至少发生<br>M次修改，则将redis抓去快照到磁盘。工作原理：当redis需要做持久化时，只需要fork一个子进程，子进程将数据写入到磁盘上的一个临时<br>文件RDB中，当子进程完成后，将原来的RDB文件替换掉，这样的好处是copy-on-write。</li>
<li>AOF方式：append only file，文件日志追加，当开启后，redis每执行一次修改数据的命令后，都会把它添加到aof文件中，当redis<br>重启时，进行”重放”，以恢复redis关闭前的最后时刻。AOF的三中方式：每提交一个修改命令都刷新到aof中，非常慢，但是很安全。每秒中<br>刷盘一次，很快，但是可能会丢失一秒中的数据。第三种是依赖操作系统的缓存进行刷新，最快，但是安全性最差。</li>
</ol>
<h2 id="Redis各种特征的试用场景"><a href="#Redis各种特征的试用场景" class="headerlink" title="Redis各种特征的试用场景"></a>Redis各种特征的试用场景</h2><ol>
<li>Strings<br>Strings 数据结构是简单的key-value类型，value其实不仅是String，也可以是数字。<br>setnx 设置可以为对应的值为String类型的value，如果key存在返回0不覆盖，不存在返回1<br>常规key-value缓存应用。<br>常规计数: 微博数, 粉丝数</li>
<li>Hashs<br>在Memcached中，我们经常将一些结构化的信息打包成hashmap，在客户端序列化后存储为一个字符串的值，比如用户的昵称. 年龄. 性别. 积分等，这时候在需要修改其中某一项时，<br>通常需要将所有值取出反序列化后，修改某一项的值，再序列化存储回去。这样不仅增大了开销，也不适用于一些可能并发操作的场合（比如两个并发的操作都需要修改积分）。<br>而Redis的Hash结构可以使你像在数据库中Update一个属性一样只修改某一项属性值。<br>它是一个String类型的field和value的映射表，它的添加和删除都是平均的，hash特别适合用于存储对象，对于将对象存储成字符串而言，hash会占用更少的内存，<br>并且可以更方便的存取整个对象. 它和java的HashMap完全类似<br>使用场景<br>存储部分变更数据<br>如用户信息等。</li>
<li>Lists<br>Lists 就是链表，略有数据结构知识的人都应该能理解其结构。使用Lists结构，我们可以轻松地实现最新消息排行等功能。Lists的另一个应用就是消息队列，可以利用Lists的PUSH操作，将任务存在Lists中，<br>然后工作线程再用POP操作将任务取出进行执行。Redis还提供了操作Lists中某一段的api，你可以直接查询，删除Lists中某一段的元素。<br>Redis的list是每个子元素都是String类型的双向链表，可以通过push和pop操作从列表的头部或者尾部添加或者删除元素，这样List即可以作为栈，也可以作为队列。<br>消息队列系统<br>使用list可以构建队列系统，使用sorted set甚至可以构建有优先级的队列系统。<br>比如：将Redis用作日志收集器<br>实际上还是一个队列，多个端点将日志信息写入Redis，然后一个worker统一将所有日志写到磁盘。<br>取最新N个数据的操作<br>记录前N个最新登陆的用户Id列表，超出的范围可以从数据库中获得。<br>&#x2F;&#x2F;把当前登录人添加到链表里<br>ret &#x3D; r.lpush(“login:last_login_times”, uid)<br>&#x2F;&#x2F;保持链表只有N位<br>ret &#x3D; redis.ltrim(“login:last_login_times”, 0, N-1)<br>&#x2F;&#x2F;获得前N个最新登陆的用户Id列表<br>last_login_list &#x3D; r.lrange(“login:last_login_times”, 0, N-1)<br>比如sina微博：<br>在Redis中我们的最新微博ID使用了常驻缓存，这是一直更新的。但是我们做了限制不能超过5000个ID，因此我们的获取ID函数会一直询问Redis。只有在start&#x2F;count参数超出了这个范围的时候，才需要去访问数据库。<br>我们的系统不会像传统方式那样“刷新”缓存，Redis实例中的信息永远是一致的。SQL数据库（或是硬盘上的其他类型数据库）只是在用户需要获取“很远”的数据时才会被触发，而主页或第一个评论页是不会麻烦到硬盘上的数据库了。<br>Sets<br>Sets 就是一个集合，集合的概念就是一堆不重复值的组合。利用Redis提供的Sets数据结构，可以存储一些集合性的数据。<br>案例：<br>在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis还为集合提供了求交集. 并集. 差集等操作，可以非常方便的实现如共同关注. 共同喜好. 二度好友等功能，对上面的所有集合操作，<br>你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。<br>Set是集合，是String类型的无序集合，set是通过hashtable实现的，概念和数学中个的集合基本类似，可以交集，并集，差集等等，set中的元素是没有顺序的。</li>
</ol>
<p>Sorted Sets<br>和Sets相比，Sorted Sets增加了一个权重参数score，使得集合中的元素能够按score进行有序排列，比如一个存储全班同学成绩的Sorted Sets，其集合value可以是同学的学号，而score就可以是其考试得分，<br>这样在数据插入集合的时候，就已经进行了天然的排序。<br>可以用Sorted Sets来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。<br>比如在线游戏的排行榜，根据得分你通常想要：</p>
<ul>
<li>列出前100名高分选手</li>
<li>列出某用户当前的全球排名</li>
</ul>
<h1 id="seckill"><a href="#seckill" class="headerlink" title="seckill"></a>seckill</h1><h2 id="典型的秒杀系统："><a href="#典型的秒杀系统：" class="headerlink" title="典型的秒杀系统："></a>典型的秒杀系统：</h2><ol>
<li>典型的秒杀系统由接入层. 逻辑服务层. 存储层与缓存构成。Proxy处理请求接入，Server承载主要的业务逻辑，Cache用于缓存库存数量. DB则用于数据持久化。</li>
<li>一个秒杀系统对应DB中一条库存记录，当用户秒杀商品时，系统主要逻辑在于DB中库存的操作，一般对DB操作流程主要有以下三方面，1.锁库存. 2.插入秒杀记录. 3.更新库存，锁<br>库存避免超卖情况，同时要求这三步操作需要在一个事务中完成，作为单个逻辑工作单元执行，要么全部成功，要么全部失败。</li>
<li>秒杀系统设计难点，就在这个事务的操作上，商品库存在DB中记为一行，大量用户同时秒杀同一商品，第一个到达DB的请求锁住了这个库存记录，在第一个事物完成之前，这个锁一直被<br>第一个请求占用，后面的所有请求需要排队等待。并发请求的用户越多，DB请求就越多，排队越严重。</li>
</ol>
<h2 id="秒杀系统解决高并发问题常用方案"><a href="#秒杀系统解决高并发问题常用方案" class="headerlink" title="秒杀系统解决高并发问题常用方案"></a>秒杀系统解决高并发问题常用方案</h2><ol>
<li>方案一，使用内存操作替代实时DB事务操作。将实时扣库存的行为上移到内存Cache中操作，内存Cache操作成功直接给Server返回成功，然后异步落DB持久化。<br>优点：用内存操作替换磁盘操作，提高了并发性能。<br>缺点：在内存操作成功，但是DB持久化失败，或者内存Cache故障的情况下，DB持久化会丢数据。</li>
<li>方案二 使用乐观锁代替悲观锁：<br>悲观锁：关系数据库管理系统中一种并发控制的方法。<br>乐观锁：它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，会检查该事务读取的数据后，有没有其他事务对数据<br>进行了修改，如果有修改，正在提交的事务会回滚。<br>商品秒杀系统中，乐观锁的具体应用方法，是在DB的库存记录中维护一个版本号，在更新库存之前，先去DB获取当前版本号，在更新库存的事务提交时，检查版本号是否已经被其他事务修改，如果没有修改，<br>则提交事务，且版本号+1，如果版本号已经被其他事务修改，那么回滚事务，并报错。<br>优点：提高了DB并发处理的能力<br>缺点：采用乐观锁的方式，会带来大数据量的无效更新，事务回滚，给DB造成不必要的压力。用户体验也十分不好。</li>
</ol>
<h2 id="秒杀系统的挑战"><a href="#秒杀系统的挑战" class="headerlink" title="秒杀系统的挑战"></a>秒杀系统的挑战</h2><ol>
<li>对现有网站业务造成冲击</li>
<li>高并发下的应用. 数据库压力</li>
<li>突然增加的网络及服务器宽带</li>
<li>直接下单，下单页面的URL，需要动态化</li>
</ol>
<h2 id="秒杀系统的应对策略"><a href="#秒杀系统的应对策略" class="headerlink" title="秒杀系统的应对策略"></a>秒杀系统的应对策略</h2><ol>
<li>秒杀系统独立部署</li>
<li>秒杀系统页面静态化，用户请求不需要经过应用服务器的业务逻辑，也不需要访问数据库。</li>
<li>租赁秒杀网络宽带，需要将秒杀商品网页缓存到CDN，同样需要和CDN服务商临时租赁新增的出口宽带。</li>
<li>动态生成下单页面的URL，为了避免用户直接访问下单页面的URL，需要将URL动态化。在下单页面的URL加入由服务端生成的随机数作为参数，在秒杀开始的时候才能得到。</li>
</ol>
<h2 id="秒杀系统架构设计"><a href="#秒杀系统架构设计" class="headerlink" title="秒杀系统架构设计"></a>秒杀系统架构设计</h2><ol>
<li>秒杀页面尽量设计的简单</li>
<li>下单页也一样，尽量简单。只有第一个提交的订单会发送到网站的订单系统，其他用户提交订单后，只能看到秒杀结束页面。</li>
</ol>
<h2 id="如何控制秒杀商品页面购买按钮的点亮"><a href="#如何控制秒杀商品页面购买按钮的点亮" class="headerlink" title="如何控制秒杀商品页面购买按钮的点亮"></a>如何控制秒杀商品页面购买按钮的点亮</h2><p>使用javascript脚本控制，在秒杀商品静态页面加入一个javaScript文件引用，该javaScript文件中加入秒杀是否开始的标志和下单页面URL的随机参数，当秒杀开始的时候，生成一个新的javaScript文件并被用户浏览器加载，控制秒杀商品页面的展示，这个javaScript文件使用随机版本号，并且不做浏览器. CDN和反向代理服务器缓存。javaScript文件非常小，及时每次浏览器刷新都访问javaScript文件服务器也不会对服务器集群和网络宽带造成太大压力。</p>
<h2 id="如何只允许第一个提交的订单被发送到订单子系统。"><a href="#如何只允许第一个提交的订单被发送到订单子系统。" class="headerlink" title="如何只允许第一个提交的订单被发送到订单子系统。"></a>如何只允许第一个提交的订单被发送到订单子系统。</h2><ol>
<li>在用户提交订单时，需要检查是否已经有订单提交了。可以控制进入下单页面的入口，只有少数用户能进入到下单页，其他用户直接进入秒杀结束页面。</li>
</ol>
<h1 id="service"><a href="#service" class="headerlink" title="service"></a>service</h1><h2 id="微服务故障"><a href="#微服务故障" class="headerlink" title="微服务故障"></a>微服务故障</h2><ol>
<li>分布式调用故障<br> 序列化. 反序列化故障<br> 分布式路由故障<br> 网络通信故障</li>
<li>第三方服务故障，微服务会依赖第三方服务，包括数据库服务. 文件存储服务. 缓存服务. 消息队列服务等<br> 网络通信类故障<br> 雪崩效应，导致的级联故障，例如服务处理缓慢导致客户端线程被阻塞<br> 第三方不可用，导致微服务处理失败</li>
<li>微服务之间的故障<br> 处理较慢的微服务会阻塞其他服务<br> 某个微服务故障蔓延，导致整个进程不可用OOM<br> 低优先级的微服务，抢占高优先级微服务的资源</li>
</ol>
<h2 id="服务故障隔离"><a href="#服务故障隔离" class="headerlink" title="服务故障隔离"></a>服务故障隔离</h2><ol>
<li>IO操作故障隔离：网络IO. 磁盘IO. 数据库</li>
<li>资源故障隔离<br> 通信链路隔离<br> 调度资源隔离：微服务之间隔离. 第三方依赖隔离<br> 进程级隔离：VM隔离. 进程级隔离</li>
<li>容错能力<br> 路由容错：失败重试. 失败回调. 快速失败<br> 服务降级：强制降级. 容错降级<br> 熔断：全部拒绝. 部分拒绝</li>
<li>流量控制</li>
</ol>
<h2 id="故障隔离技术"><a href="#故障隔离技术" class="headerlink" title="故障隔离技术"></a>故障隔离技术</h2><p>同步I&#x2F;O主要弊端:<br>I&#x2F;O操作同步阻塞, 受制于网络和第三方处理速度  I&#x2F;O线程效率低,容易发生 线程数量膨胀. 通信队列积压 等问题<br>优化策略:<br>TCP私有协议:建议直接基于 Netty开发<br>HTTP&#x2F;Restful&#x2F;SOAP等:选择支 持非阻塞I&#x2F;O的Web框架。可以选 择基于Netty构建的开源应用层 协议栈框架</p>
<h2 id="RPC通信链路隔离"><a href="#RPC通信链路隔离" class="headerlink" title="RPC通信链路隔离"></a>RPC通信链路隔离</h2><p>隔离策略:</p>
<ol>
<li>微服务节点之间支持配置多链路</li>
<li>微服务链路支持不同的隔离策略: 例如根据消息码流大小. 根据微服务的优先级等策略,实现链路级的隔离</li>
</ol>
<h2 id="微服务调度隔离"><a href="#微服务调度隔离" class="headerlink" title="微服务调度隔离"></a>微服务调度隔离</h2><p>关键技术点:</p>
<ol>
<li>微服务发布时支持指定线程池&#x2F;线程组</li>
<li>微服务线程池支持独享和共享两种模式  微服务和线程池监控,识别故障微服务, 动态调整到故障隔离线程池中</li>
<li>支持按照微服务优先级调度微服务, 即微服务线程支持微服务优先级调度</li>
</ol>
<h2 id="第三方服务依赖隔离"><a href="#第三方服务依赖隔离" class="headerlink" title="第三方服务依赖隔离"></a>第三方服务依赖隔离</h2><p>关键技术点:</p>
<ol>
<li>第三方依赖隔离可以采用线程池 + 响应式编程(例如RxJava)的方式实现 </li>
<li>对第三方依赖进行分类,每种依赖对应一个独立的线程&#x2F;线程池</li>
<li>微服务不直接调用第三方依赖的API,而是使用异步封装之后的API接口</li>
<li>异步调用第三方依赖API之后,获取Future对象。利用响应式编程框架, 可以订阅后续的事件,接收响应,针对响应进行编程</li>
</ol>
<h2 id="微服务进程隔离-Docker容器"><a href="#微服务进程隔离-Docker容器" class="headerlink" title="微服务进程隔离(Docker容器)"></a>微服务进程隔离(Docker容器)</h2><p>关键技术点:</p>
<ol>
<li>微服务独立开发. 打包和部署</li>
<li>基于Docker部署微服务,可以实现细粒度的资源隔离,实现微服务的高密度部署。<br>优势:</li>
<li>高效:微服务的启动和销毁速度非常快, 可以实现秒级弹性伸缩</li>
<li>高性能:Docker容器的性能接近裸的物理机, 综合性能损耗 &lt; 5%</li>
<li>可移植性:“一次编写,到处运行”</li>
</ol>
<h2 id="分布式路由容错"><a href="#分布式路由容错" class="headerlink" title="分布式路由容错"></a>分布式路由容错</h2><ol>
<li>失败自动重试:微服务调用失败自动重试</li>
<li>失败自动切换:当发生服务调用异常时,重新选路,查找下一个可用的微服务提供者 </li>
<li>快速失败:对于一些非核心的服务,希望只调用一次,失败也不再重试</li>
<li>失败回调:提供异常回调接口,执行微服务消费者自定义的失败处理逻辑</li>
</ol>
<h2 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h2><ol>
<li>强制降级:不发起远程服务调用,执行本地降级策略,例如本地Mock方法 </li>
<li>容错降级:当非核心服务不可用时,可以对故障服务做业务逻辑放通,以￼￼保障核心服务的运行,降级策略包括异常转换. 本地放通方法调用</li>
</ol>
<h2 id="熔断机制"><a href="#熔断机制" class="headerlink" title="熔断机制"></a>熔断机制</h2><ol>
<li>熔断判断:微服务调用时, 对熔断开关状态进行判断,当熔断器开关关闭时, 请求被允许通过熔断器</li>
<li>熔断执行:当熔断器开关打 开时,微服务调用请求被禁止通过,执行失败回调接口</li>
<li>自动恢复:熔断之后,周期T 之后允许一条消息通过,如果成功,则取消熔断状态,否则继续处于熔断状态</li>
</ol>
<h1 id="spark"><a href="#spark" class="headerlink" title="spark"></a>spark</h1><h2 id="什么是Spark"><a href="#什么是Spark" class="headerlink" title="什么是Spark"></a>什么是Spark</h2><ol>
<li>Apache Spark是一个围绕速度. 易用性和复杂分析构建的大数据处理框架。<br>最初在2009年由加州大学伯克利分校的AMPLab开发，并于2010年成为Apache的开源项目之一。</li>
<li>Spark为我们提供了一个全面. 统一的框架用于管理各种有着不同性质（文本数据. 图表数据等）的数据集和数据源（批量数据或实时的流数据）的大数据处理的需求。</li>
<li>Spark可以将Hadoop集群中的应用在内存中的运行速度提升100倍，甚至能够将应用在磁盘上的运行速度提升10倍。</li>
<li>除了Map和Reduce操作之外，它还支持SQL查询，流数据，机器学习和图表数据处理。<br>开发者可以在一个数据管道用例中单独使用某一能力或者将这些能力结合在一起使用。</li>
</ol>
<h2 id="Spark特性"><a href="#Spark特性" class="headerlink" title="Spark特性"></a>Spark特性</h2><ol>
<li>Spark通过在数据处理过程中成本更低的洗牌（Shuffle）方式，将MapReduce提升到一个更高的层次。利用内存数据存储和接近实时的处理能力，Spark比其他的大数据处理技术的性能要快很多倍。</li>
<li>Spark还支持大数据查询的延迟计算，这可以帮助优化大数据处理流程中的处理步骤。Spark还提供高级的API以提升开发者的生产力，除此之外还为大数据解决方案提供一致的体系架构模型。</li>
<li>Spark将中间结果保存在内存中而不是将其写入磁盘，当需要多次处理同一数据集时，这一点特别实用。Spark的设计初衷就是既可以在内存中又可以在磁盘上工作的执行引擎。当内存中的数据不适用时，Spark操作符就会执行外部操作。Spark可以用于处理大于集群内存容量总和的数据集。</li>
<li>Spark会尝试在内存中存储尽可能多的数据然后将其写入磁盘。它可以将某个数据集的一部分存入内存而剩余部分存入磁盘。开发者需要根据数据和用例评估对内存的需求。Spark的性能优势得益于这种内存中的数据存储</li>
</ol>
<h2 id="Spark生态系统"><a href="#Spark生态系统" class="headerlink" title="Spark生态系统"></a>Spark生态系统</h2><ol>
<li>Spark Streaming:<br> Spark Streaming基于微批量方式的计算和处理，可以用于处理实时的流数据。它使用DStream，简单来说就是一个弹性分布式数据集（RDD）系列，处理实时数据。</li>
<li>Spark SQL:<br> Spark SQL可以通过JDBC API将Spark数据集暴露出去，而且还可以用传统的BI和可视化工具在Spark数据上执行类似SQL的查询。用户还可以用Spark SQL对不同格式的数据（如JSON，Parquet以及数据库等）执行ETL，将其转化，然后暴露给特定的查询。</li>
<li>Spark MLlib:<br> MLlib是一个可扩展的Spark机器学习库，由通用的学习算法和工具组成，包括二元分类. 线性回归. 聚类. 协同过滤. 梯度下降以及底层优化原语。</li>
<li>Spark GraphX:<br> GraphX是用于图计算和并行图计算的新的（alpha）Spark API。通过引入弹性分布式属性图（Resilient Distributed Property Graph），一种顶点和边都带有属性的有向多重图，扩展了Spark RDD。为了支持图计算，<br> GraphX暴露了一个基础操作符集合（如subgraph，joinVertices和aggregateMessages）和一个经过优化的Pregel API变体。此外，GraphX还包括一个持续增长的用于简化图分析任务的图算法和构建器集合。</li>
<li>BlinkDB是一个近似查询引擎，用于在海量数据上执行交互式SQL查询。BlinkDB可以通过牺牲数据精度来提升查询响应时间。通过在数据样本上执行查询并展示包含有意义的错误线注解的结果，操作大数据集合。</li>
<li>Tachyon是一个以内存为中心的分布式文件系统，能够提供内存级别速度的跨集群框架（如Spark和MapReduce）的可信文件共享。它将工作集文件缓存在内存中，从而避免到磁盘中加载需要经常读取的数据集。通过这一机制，不同的作业&#x2F;查询和框架可以以内存级的速度访问缓存的文件。<br>此外，还有一些用于与其他产品集成的适配器，如Cassandra（Spark Cassandra 连接器）和R（SparkR）。Cassandra Connector可用于访问存储在Cassandra数据库中的数据并在这些数据上执行数据分析。</li>
</ol>
<h2 id="Spark体系架构"><a href="#Spark体系架构" class="headerlink" title="Spark体系架构"></a>Spark体系架构</h2><p>Spark体系架构包括如下三个主要组件：</p>
<ol>
<li><p>数据存储</p>
</li>
<li><p>API</p>
</li>
<li><p>管理框架</p>
</li>
<li><p>数据存储：<br>Spark用HDFS文件系统存储数据。它可用于存储任何兼容于Hadoop的数据源，包括HDFS，HBase，Cassandra等。</p>
</li>
<li><p>API：<br>利用API，应用开发者可以用标准的API接口创建基于Spark的应用。Spark提供Scala，Java和Python三种程序设计语言的API。<br>下面是三种语言Spark API<br>Scala API<br>Java<br>Python</p>
</li>
<li><p>资源管理：<br>Spark既可以部署在一个单独的服务器也可以部署在像Mesos或YARN这样的分布式计算框架之上。</p>
</li>
</ol>
<h2 id="Spark体系架构-1"><a href="#Spark体系架构-1" class="headerlink" title="Spark体系架构"></a>Spark体系架构</h2><ol>
<li>弹性分布式数据集：弹性分布式数据集（基于Matei的研究论文）或RDD是Spark框架中的核心概念。可以将RDD视作数据库中的一张表。其中可以保存任何类型的数据。Spark将数据存储在不同分区上的RDD之中。<br>RDD可以帮助重新安排计算并优化数据处理过程。此外，它还具有容错性，因为RDD知道如何重新创建和重新计算数据集。RDD是不可变的。你可以用变换（Transformation）修改RDD，但是这个变换所返回的是一个全新的RDD，而原有的RDD仍然保持不变。<br>RDD支持两种类型的操作：<br>变换（Transformation）<br>行动（Action）</li>
</ol>
<h2 id="变换：变换的返回值是一个新的RDD集合，而不是单个值。调用一个变换方法，不会有任何求值计算，它只获取一个RDD作为参数，然后返回一个新的RDD。"><a href="#变换：变换的返回值是一个新的RDD集合，而不是单个值。调用一个变换方法，不会有任何求值计算，它只获取一个RDD作为参数，然后返回一个新的RDD。" class="headerlink" title="变换：变换的返回值是一个新的RDD集合，而不是单个值。调用一个变换方法，不会有任何求值计算，它只获取一个RDD作为参数，然后返回一个新的RDD。"></a>变换：变换的返回值是一个新的RDD集合，而不是单个值。调用一个变换方法，不会有任何求值计算，它只获取一个RDD作为参数，然后返回一个新的RDD。</h2><p>变换函数包括：map，filter，flatMap，groupByKey，reduceByKey，aggregateByKey，pipe和coalesce。</p>
<h2 id="行动：行动操作计算并返回一个新的值。当在一个RDD对象上调用行动函数时，会在这一时刻计算全部的数据处理查询并返回结果值。"><a href="#行动：行动操作计算并返回一个新的值。当在一个RDD对象上调用行动函数时，会在这一时刻计算全部的数据处理查询并返回结果值。" class="headerlink" title="行动：行动操作计算并返回一个新的值。当在一个RDD对象上调用行动函数时，会在这一时刻计算全部的数据处理查询并返回结果值。"></a>行动：行动操作计算并返回一个新的值。当在一个RDD对象上调用行动函数时，会在这一时刻计算全部的数据处理查询并返回结果值。</h2><p>行动操作包括：reduce，collect，count，first，take，countByKey以及foreach。</p>
<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><h2 id="synchronized是java的关键字，是一种同步锁"><a href="#synchronized是java的关键字，是一种同步锁" class="headerlink" title="synchronized是java的关键字，是一种同步锁"></a>synchronized是java的关键字，是一种同步锁</h2><ol>
<li>修饰代码块，被修饰的代码块成为同步代码块，其作用范围是大括号括起来的代码，作用的对象是调用这个代码块的对象。</li>
<li>修饰一个方法，被修饰的方法成为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象。</li>
<li>修改是一个静态方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象。</li>
</ol>
<h2 id="零长度的byte数组创建起来比任何对象都经济，生成0长度的byte-对象只需要3条字节码-而创建一个Object则需要7步骤。"><a href="#零长度的byte数组创建起来比任何对象都经济，生成0长度的byte-对象只需要3条字节码-而创建一个Object则需要7步骤。" class="headerlink" title="零长度的byte数组创建起来比任何对象都经济，生成0长度的byte[]对象只需要3条字节码. 而创建一个Object则需要7步骤。"></a>零长度的byte数组创建起来比任何对象都经济，生成0长度的byte[]对象只需要3条字节码. 而创建一个Object则需要7步骤。</h2><h2 id="并发访问时需要注意事项"><a href="#并发访问时需要注意事项" class="headerlink" title="并发访问时需要注意事项"></a>并发访问时需要注意事项</h2><ol>
<li>当2个并发线程访问一个对象Object中的这个Synchronized同步代码块时，一个时间内只能有一个线程得到执行，另一个线程必须等待<br>当前线程执行完，才能执行。</li>
<li>当一个线程访问Object的Synchronized方法时，另一个线程可以访问非synchronized的同步代码块。</li>
<li>当一个线程访问Object的Synchronized方法时，其他线程对Object中所有其他Synchronized同步代码块的访问将阻塞。</li>
<li>静态方法属于类，而不属于任何一个对象，synchronized修饰的静态方法锁定这个对象的所有类。<br>总结：</li>
<li>无论synchronized关键字加在方法上还是对象上，如果它作用的是非静态的，则它取得的锁是对象。如果一个synchronized作用的对象<br>是一个静态方法或者一个类，则它获取的锁是对该类所有对象的同一把锁。</li>
</ol>
<h1 id="system"><a href="#system" class="headerlink" title="system"></a>system</h1><h2 id="高并发服务器建议调小-TCP-协议的-time-wait-超时时间"><a href="#高并发服务器建议调小-TCP-协议的-time-wait-超时时间" class="headerlink" title="高并发服务器建议调小 TCP 协议的 time_wait 超时时间"></a>高并发服务器建议调小 TCP 协议的 time_wait 超时时间</h2><p>说明:操作系统默认 240 秒后,才会关闭处于 time_wait 状态的连接,在高并发访问下,服 务器端会因为处于 time_wait 的连接数太多,可能无法建立新的连接,所以需要在服务器上 调小此等待值。<br>正例:在 linux 服务器上请通过变更&#x2F;etc&#x2F;sysctl.conf 文件去修改该缺省值(秒):<br>net.ipv4.tcp_fin_timeout &#x3D; 30</p>
<h2 id="调大服务器所支持的最大文件句柄数-File-Descriptor-简写为fd"><a href="#调大服务器所支持的最大文件句柄数-File-Descriptor-简写为fd" class="headerlink" title="调大服务器所支持的最大文件句柄数(File Descriptor,简写为fd)"></a>调大服务器所支持的最大文件句柄数(File Descriptor,简写为fd)</h2><p>说明:主流操作系统的设计是将 TCP&#x2F;UDP 连接采用与文件一样的方式去管理,即一个连接对 应于一个 fd。<br>主流的 linux 服务器默认所支持最大 fd 数量为 1024,当并发连接数很大时很 容易因为 fd 不足而出现“open too many files”错误,导致新的连接无法建立。<br>建议将 linux 服务器所支持的最大句柄数调高数倍(与服务器的内存数量相关)。</p>
<h2 id="给-JVM-设置-XX-HeapDumpOnOutOfMemoryError-参数-让-JVM-碰到-OOM-场景时输出-dump-信息"><a href="#给-JVM-设置-XX-HeapDumpOnOutOfMemoryError-参数-让-JVM-碰到-OOM-场景时输出-dump-信息" class="headerlink" title="给 JVM 设置-XX:+HeapDumpOnOutOfMemoryError 参数,让 JVM 碰到 OOM 场景时输出 dump 信息"></a>给 JVM 设置-XX:+HeapDumpOnOutOfMemoryError 参数,让 JVM 碰到 OOM 场景时输出 dump 信息</h2><p>说明:OOM 的发生是有概率的,甚至有规律地相隔数月才出现一例,出现时的现场信息对查错 非常有价值。</p>
<h2 id="服务器内部重定向使用-forward，外部重定向地址使用-URL-拼装工具类来生成-否则-会带来-URL-维护不一致的问题和潜在的安全风险。"><a href="#服务器内部重定向使用-forward，外部重定向地址使用-URL-拼装工具类来生成-否则-会带来-URL-维护不一致的问题和潜在的安全风险。" class="headerlink" title="服务器内部重定向使用 forward，外部重定向地址使用 URL 拼装工具类来生成,否则 会带来 URL 维护不一致的问题和潜在的安全风险。"></a>服务器内部重定向使用 forward，外部重定向地址使用 URL 拼装工具类来生成,否则 会带来 URL 维护不一致的问题和潜在的安全风险。</h2><h1 id="threadpoolexecutor"><a href="#threadpoolexecutor" class="headerlink" title="threadpoolexecutor"></a>threadpoolexecutor</h1><h2 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h2><ol>
<li>corePoolSize：线程池维护线程的最小数量。</li>
<li>maxinumPoolSize：线程池维护线程的最大数量。</li>
<li>keepAliveTime:线程池维护线程所允许的空闲时间。</li>
<li>unit：空闲时间对应的时间单元。</li>
<li>workQueue:线程池所使用的缓冲队列</li>
</ol>
<h2 id="线程池对拒绝任务的处理策略"><a href="#线程池对拒绝任务的处理策略" class="headerlink" title="线程池对拒绝任务的处理策略"></a>线程池对拒绝任务的处理策略</h2><ol>
<li>不使用线程池线程执行。</li>
<li>直接丢弃当前任务。</li>
<li>丢弃队列中最旧的任务。</li>
<li>抛出异常。<br>这四种策略是独立无关的，是对任务拒绝处理的四种表现形式。最简单的方式就是直接丢弃任务。<br>但是却有两种方式，到底是改丢弃哪一个任务，比如可以丢弃当前将要加入队列的任务本身，或者丢弃任务队列最旧任务。<br>丢弃最旧任务也不是简单的丢弃最旧的任务，而是有一些额外的处理。除了丢弃任务还可以抛出异常，这是比较简单的方式。<br>抛出异常的方式比较简单，但是会中断调用者的处理过程，除了抛出异常还可以不进入线程池执行，在这种方式中，任务将由调用者去执行。</li>
</ol>
<h1 id="transaction"><a href="#transaction" class="headerlink" title="transaction"></a>transaction</h1><h2 id="数据库事务的四个特性ACID："><a href="#数据库事务的四个特性ACID：" class="headerlink" title="数据库事务的四个特性ACID："></a>数据库事务的四个特性ACID：</h2><ol>
<li>原子性：事务是一个原子操作，由一系列动作组成，要么全部成功，要么全部失败。</li>
<li>一致性：事物开启到结束，数据库的完整性没有被破坏，一个事务执行之前和执行之后都必须处于一致性状态。</li>
<li>隔离性：事务之间相互隔离，互不影响。</li>
<li>持久性：事务一旦提交，影响将是永久性的。</li>
</ol>
<h1 id="weakhashmap"><a href="#weakhashmap" class="headerlink" title="weakhashmap"></a>weakhashmap</h1><h2 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h2><p>它的特殊之处在于 WeakHashMap 里的entry可能会被GC自动删除，即使程序员没有调用remove()或者clear()方法。<br>使用 WeakHashMap 时，即使没有显示的添加或删除任何元素，也可能发生如下情况：<br>    调用两次size()方法返回不同的值；<br>    两次调用isEmpty()方法，第一次返回false，第二次返回true；<br>    两次调用containsKey()方法，第一次返回true，第二次返回false，尽管两次使用的是同一个key；<br>    两次调用get()方法，第一次返回一个value，第二次返回null，尽管两次使用的是同一个对象。</p>
<h2 id="WeekHashMap用途："><a href="#WeekHashMap用途：" class="headerlink" title="WeekHashMap用途："></a>WeekHashMap用途：</h2><p>WeekHashMap 的这个特点特别适用于需要缓存的场景。在缓存场景下，由于内存是有限的，不能缓存所有对象；<br>对象缓存命中可以提高系统效率，但缓存MISS也不会造成错误，因为可以通过计算重新得到。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>要明白 WeekHashMap 的工作原理，还需要引入一个概念：弱引用（WeakReference）。我们都知道Java中内存是通过GC自动管理的，GC会在程序运行过程中自动判断哪些对象是可以被回收的，并在合适的时机进行内存释放。<br>GC判断某个对象是否可被回收的依据是，是否有有效的引用指向该对象。如果没有有效引用指向该对象（基本意味着不存在访问该对象的方式），那么该对象就是可回收的。这里的“有效引用”并不包括弱引用。<br>也就是说，虽然弱引用可以用来访问对象，但进行垃圾回收时弱引用并不会被考虑在内，仅有弱引用指向的对象仍然会被GC回收。<br>WeakHashMap 内部是通过弱引用来管理entry的，弱引用的特性对应到 WeakHashMap 上意味着什么呢？将一对key, value放入到 WeakHashMap 里并不能避免该key值被GC回收，<br>除非在 WeakHashMap 之外还有对该key的强引用。</p>
<h1 id="web"><a href="#web" class="headerlink" title="web"></a>web</h1><h2 id="静态化系统的特征"><a href="#静态化系统的特征" class="headerlink" title="静态化系统的特征"></a>静态化系统的特征</h2><ol>
<li>一个页面对应的URL通常是固定的。不同的URL标识不同的内容。</li>
<li>页面中不能包含与浏览者相关的因素，例如JS动态生成的部分，还有用户的姓名. 身份等。</li>
<li>在页面中不能包含时间因素。</li>
<li>在页面中不能包含地域因素。</li>
<li>不能包含Cookie等私有数据。</li>
</ol>
<h2 id="为什么要进行静态化架构设计"><a href="#为什么要进行静态化架构设计" class="headerlink" title="为什么要进行静态化架构设计"></a>为什么要进行静态化架构设计</h2><ol>
<li>系统进行多次升级，包括架构升级，系统本身升级，代码优化，增加各种缓存，这些java系统中做的优化，不能满足要求。<br>java本身不擅长处理大量连接的请求，每个连接消耗的内存较多。</li>
<li>所以需要跳出java系统，在前面的web服务层直接返回。</li>
</ol>
<h2 id="静态化系统的优点："><a href="#静态化系统的优点：" class="headerlink" title="静态化系统的优点："></a>静态化系统的优点：</h2><ol>
<li>改变了缓存的方式，直接缓存HTTP连接，而不是仅仅缓存数据。web代理服务器根据请求URL直接取出对应的HTTP响应头<br>和响应提直接返回。这个响应连HTTP都不用重新组装。</li>
<li>改变了缓存的地方。不是在java层面做缓存，而是直接在web服务层做，屏蔽了java的一些弱点。</li>
</ol>
<h2 id="如何动态改造系统"><a href="#如何动态改造系统" class="headerlink" title="如何动态改造系统"></a>如何动态改造系统</h2><ol>
<li>动静分离</li>
<li>组装动态内容：<br>2.1 ESI，在Web代理服务器上做动态内容请求，并将请求插入到静态页面中。当用户拿到页面已经是一个完整的页面了。这种对服务器<br>性能有些影响，但是用户体验是好的。<br>2.2 CSI，这种方式就是发起一个异步JS请求单独向服务器获取动态内容。这种方式使服务器性能更佳，但是用户端页面有些延迟，体验<br>稍差。</li>
</ol>
<h1 id="zk"><a href="#zk" class="headerlink" title="zk"></a>zk</h1><h2 id="流行的应用场景"><a href="#流行的应用场景" class="headerlink" title="流行的应用场景"></a>流行的应用场景</h2><ol>
<li>分布式配置管理<br>发布与订阅即所谓的配置管理，顾名思义就是将数据发布到zk的节点上，供订阅者动态获取数据，实现配置信息的集中式管理和动态更新，例如全局的配置信息，地址列表等就非常的适合使用。</li>
<li>Name Server<br>这个主要是用作分布式命名服务，通过调用zk的create node api，能够很容易创建一个全局唯一的path，这个path就可以作为一个名称。</li>
<li>分布式通知&#x2F;协调<br>Zookeeper中特有的watcher注册与异步通知机制，能够很好的实现分布式环境下不同系统之间的通知与协调，实现对数据变更的实时处理。使用方法通常是不同系统都对zk上同一个znode进行注册，监听znode的变化（包括znode本身内容以及子节点的），其中一个系统update了znode，那么另外一个系统能够收到通知，并作出对应的处理。</li>
<li>分布式锁<br>分布式锁，这个主要得益于zookeeper为我们保证了数据的强一致性，即用户只要完全相信每时每刻，zk集群中任意的借点（一个zk server）上的相同znode的数据是一定相同的。锁服务可以氛围两类，一个是保持独占，另一个是控制时序。</li>
<li>集群管理<br>Hbase Master 选举则是zookeeper经典的使用场景；<br>Storm集群管理。</li>
<li>分布式队列<br>队列方面一种是常规的先进先出队列，另外一种是要等到队列成员都聚齐之后才统一按序执行，对于第二种先进先出队列，增加分布式锁服务以控制时序场景。</li>
</ol>
</article><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://czcsw-1256525464.cos.ap-chengdu.myqcloud.com/images/blog/wechat_pay.jpeg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://czcsw-1256525464.cos.ap-chengdu.myqcloud.com/images/blog/wechat_pay.jpeg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://czcsw-1256525464.cos.ap-chengdu.myqcloud.com/images/blog/alipay.jpeg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://czcsw-1256525464.cos.ap-chengdu.myqcloud.com/images/blog/alipay.jpeg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div><div class="reward-link mode"><a class="reward-link-button" href="/atom.xml" data-pjax-state=""><i class="anzhiyufont anzhiyu-icon-plant-fill"></i>运营模式与责任</a></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://chengzc.club/posts/969553277/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=JAVA学习&amp;url=https://chengzc.club/posts/969553277/&amp;pic=https://czcsw-1256525464.cos.ap-chengdu.myqcloud.com/images/blog/20230414/1681405751001/900000100.jpg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/JAVA/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>JAVA<span class="tagsPageCount">2</span></a><a class="post-meta__box__tags" href="/tags/%E7%AC%94%E8%AE%B0/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>笔记<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://czcsw-1256525464.cos.ap-chengdu.myqcloud.com/images/blog/20230414/1681405898521/300000298.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://npm.elemecdn.com/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://npm.elemecdn.com/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div></div><div class="post-copyright"><i class="anzhiyufont anzhiyu-icon-copyright"></i><div class="post-copyright__author"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://chengzc.club/posts/969553277/">原创</a><a class="post-copyright-title"><span>JAVA学习</span></a></div><div class="post-copyright-info-box"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"></span><a class="link" href="https://chengzc.club">ChengZC</a></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a class="link" href="https://chengzc.club/posts/969553277/">https://chengzc.club/posts/969553277/</a></span><span class="copy-button" onclick="rm.copyPageUrl('https://chengzc.club/posts/969553277/')"><i class="anzhiyufont anzhiyu-icon-copy"></i></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/865795493/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://czcsw-1256525464.cos.ap-chengdu.myqcloud.com/images/blog/20230414/1681405751001/900000397.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">关于使用码云，GITHUB,阿里云CODE来管理代码的一些操作记录</div></div></a></div><div class="next-post pull-right"><a href="/posts/3851689809/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://czcsw-1256525464.cos.ap-chengdu.myqcloud.com/images/blog/20230414/1681405751001/900000331.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">关于tomcat指定主目录和虚拟目录的问题</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/posts/207851142/" title="Jenkins持续化管理工具配置"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://czcsw-1256525464.cos.ap-chengdu.myqcloud.com/images/blog/20230414/1681405751001/900000133.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2020-04-11</div><div class="title">Jenkins持续化管理工具配置</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> Comment</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="author-info-top"> <div class="card-info-avatar"><div class="author-status-box"><div class="author-status"><g-emoji class="g-emoji" alias="writing_hand" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/270d.png">✍️</g-emoji><span>on Studying</span></div></div></div></div><div class="author-info__sayhi" id="author-info__sayhi"></div><h1 class="author-info__name">ChengZC</h1><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这有关于<b style="color:#fff">产品、设计、开发</b>相关的问题和看法，还有<b style="color:#fff">文章翻译</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="banner-button-group"><a class="banner-button" onclick="pjax.loadUrl(&quot;/about/&quot;)"><span class="banner-button-text">了解更多</span><i class="anzhiyufont anzhiyu-icon-arrow-circle-right" style="font-size: 1.5rem"></i></a></div><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/GriMu" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=2366314738@qq.com" target="_blank" title="Email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><a class="social-icon faa-parent animated-hover" href="/atom.xml" target="_blank" title="RSS"><i class="anzhiyufont anzhiyu-icon-rss"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/3999900" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a><a class="social-icon faa-parent animated-hover" href="tencent://Message/?Uin=2366314738&amp;amp;websiteName=local.edu.com:8888=&amp;amp;Menu=yes" target="_blank" title="QQ"><i class="anzhiyufont anzhiyu-icon-qq"></i></a></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://img.chengzc.club/i/2023/04/21/6441db5fe6397.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://czcsw-1256525464.cos.ap-chengdu.myqcloud.com/images/blog/20230413/gzh.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#annotation"><span class="toc-number">1.</span> <span class="toc-text">annotation</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E6%B3%A8%E8%A7%A3%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">元注解：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Target%EF%BC%8C%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="toc-number">1.2.</span> <span class="toc-text">@Target，注解的修饰的范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Retention-%E6%B3%A8%E9%87%8A%E4%BF%AE%E9%A5%B0%E7%9A%84%E6%97%B6%E9%97%B4"><span class="toc-number">1.3.</span> <span class="toc-text">Retention 注释修饰的时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Inherited-%E5%85%83%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%B8%80%E4%B8%AA%E6%A0%87%E8%AE%B0%E6%B3%A8%E8%A7%A3%EF%BC%8C%E8%A2%AB%E6%A0%87%E6%B3%A8%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%98%AF%E8%A2%AB%E7%BB%A7%E6%89%BF%E7%9A%84%E3%80%82"><span class="toc-number">1.4.</span> <span class="toc-text">@Inherited 元注解的一个标记注解，被标注的类型是被继承的。</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cdn"><span class="toc-number">2.</span> <span class="toc-text">cdn</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CDN%E7%AE%80%E4%BB%8B%EF%BC%9A"><span class="toc-number">2.1.</span> <span class="toc-text">CDN简介：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CDN%E7%BC%93%E5%AD%98%E5%86%85%E5%AE%B9%EF%BC%9A"><span class="toc-number">2.2.</span> <span class="toc-text">CDN缓存内容：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CDN%E8%A6%81%E8%BE%BE%E5%88%B0%E7%9A%84%E7%9B%AE%E6%A0%87%EF%BC%9A"><span class="toc-number">2.3.</span> <span class="toc-text">CDN要达到的目标：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9A"><span class="toc-number">2.4.</span> <span class="toc-text">负载均衡：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CDN%E5%8A%A8%E6%80%81%E5%8A%A0%E9%80%9F"><span class="toc-number">2.5.</span> <span class="toc-text">CDN动态加速</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#class"><span class="toc-number">3.</span> <span class="toc-text">class</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">3.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA"><span class="toc-number">3.2.</span> <span class="toc-text">类的加载时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.3.</span> <span class="toc-text">类的初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">3.4.</span> <span class="toc-text">类的加载过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">3.5.</span> <span class="toc-text">类加载过程：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">3.6.</span> <span class="toc-text">类的加载过程：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="toc-number">3.7.</span> <span class="toc-text">类加载器的代理模式：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-number">3.8.</span> <span class="toc-text">类加载器的层次结构：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%9A"><span class="toc-number">3.9.</span> <span class="toc-text">线程上下文加载器：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#concurrent"><span class="toc-number">4.</span> <span class="toc-text">concurrent</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#core"><span class="toc-number">5.</span> <span class="toc-text">core</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile"><span class="toc-number">5.1.</span> <span class="toc-text">volatile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%A4%B1%E6%95%88"><span class="toc-number">5.2.</span> <span class="toc-text">单例模式失效</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95"><span class="toc-number">5.3.</span> <span class="toc-text">一致性Hash算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#equals-%E5%92%8C-hashcode"><span class="toc-number">5.4.</span> <span class="toc-text">equals 和 hashcode</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#design"><span class="toc-number">6.</span> <span class="toc-text">design</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%EF%BC%9A"><span class="toc-number">6.1.</span> <span class="toc-text">设计模式的六大原则：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB"><span class="toc-number">6.2.</span> <span class="toc-text">设计模式分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="toc-number">6.3.</span> <span class="toc-text">常见设计模式：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%94%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99-solid"><span class="toc-number">6.4.</span> <span class="toc-text">面向对象的五大基本原则(solid)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#EasyCoding"><span class="toc-number">7.</span> <span class="toc-text">EasyCoding</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Cpu%E4%B8%8E%E5%86%85%E5%AD%98"><span class="toc-number">7.1.</span> <span class="toc-text">Cpu与内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-IP%E5%8D%8F%E8%AE%AE"><span class="toc-number">7.2.</span> <span class="toc-text">TCP. IP协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%B1%E5%93%8DRPC%E6%80%A7%E8%83%BD%E7%9A%84%E5%9B%A0%E7%B4%A0%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">7.3.</span> <span class="toc-text">影响RPC性能的因素如下：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Protobuf"><span class="toc-number">7.4.</span> <span class="toc-text">Protobuf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rest"><span class="toc-number">7.5.</span> <span class="toc-text">Rest</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-x2F-2%E5%8D%8F%E8%AE%AE"><span class="toc-number">7.6.</span> <span class="toc-text">HTTP&#x2F;2协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cloud-Native%E5%B1%9E%E6%80%A7%E6%80%BB%E7%BB%93"><span class="toc-number">7.7.</span> <span class="toc-text">Cloud Native属性总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gRPC"><span class="toc-number">7.8.</span> <span class="toc-text">gRPC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6"><span class="toc-number">7.9.</span> <span class="toc-text">微服务框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dubbo"><span class="toc-number">7.10.</span> <span class="toc-text">Dubbo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Etcd"><span class="toc-number">7.11.</span> <span class="toc-text">Etcd</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E7%AD%96%E7%95%A5"><span class="toc-number">7.12.</span> <span class="toc-text">微服务部署策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8VS%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">7.13.</span> <span class="toc-text">容器VS虚拟机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">7.14.</span> <span class="toc-text">分布式消息中间件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kafka%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86"><span class="toc-number">7.15.</span> <span class="toc-text">Kafka的设计原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#generic"><span class="toc-number">8.</span> <span class="toc-text">generic</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-number">8.1.</span> <span class="toc-text">概念：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-number">8.2.</span> <span class="toc-text">定义：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E4%BD%BF%E7%94%A8%E9%9C%80%E6%B3%A8%E6%84%8F%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">8.3.</span> <span class="toc-text">泛型使用需注意问题：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#http"><span class="toc-number">9.</span> <span class="toc-text">http</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E5%8D%8F%E8%AE%AE%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">9.1.</span> <span class="toc-text">HTTP协议特点：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cookie%E5%92%8CSession"><span class="toc-number">9.2.</span> <span class="toc-text">Cookie和Session</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E4%BB%8B%E7%BB%8D"><span class="toc-number">9.3.</span> <span class="toc-text">HTTP介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DNS"><span class="toc-number">9.4.</span> <span class="toc-text">DNS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Http%E5%92%8CHttps%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.5.</span> <span class="toc-text">Http和Https的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAURL%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">9.6.</span> <span class="toc-text">浏览器输入一个URL的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinuxIO%E6%A8%A1%E5%9E%8B"><span class="toc-number">9.7.</span> <span class="toc-text">LinuxIO模型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#instrumentation"><span class="toc-number">10.</span> <span class="toc-text">instrumentation</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Instrumentation"><span class="toc-number">10.1.</span> <span class="toc-text">Instrumentation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96Instrumentation%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">10.2.</span> <span class="toc-text">获取Instrumentation接口的方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Interview"><span class="toc-number">11.</span> <span class="toc-text">Interview</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E8%87%B4%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A2%91%E7%B9%81fullGC%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E9%82%A3%E4%BA%9B%EF%BC%9F"><span class="toc-number">11.1.</span> <span class="toc-text">导致服务器频繁fullGC的原因有那些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95"><span class="toc-number">11.2.</span> <span class="toc-text">限流算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8E%92%E9%98%9F%E7%AD%96%E7%95%A5"><span class="toc-number">11.3.</span> <span class="toc-text">线程池排队策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">11.4.</span> <span class="toc-text">线程通信</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#io"><span class="toc-number">12.</span> <span class="toc-text">io</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%EF%BC%9A"><span class="toc-number">12.1.</span> <span class="toc-text">字节流：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">12.2.</span> <span class="toc-text">字符流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">12.3.</span> <span class="toc-text">字节流和字符流转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">12.4.</span> <span class="toc-text">缓冲流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE-%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.5.</span> <span class="toc-text">处理数据+类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%B5%81%EF%BC%9APrintStream"><span class="toc-number">12.6.</span> <span class="toc-text">打印流：PrintStream</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E6%B5%81%E5%88%86%E7%B1%BB"><span class="toc-number">12.7.</span> <span class="toc-text">IO流分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E5%92%8C%E5%AD%97%E7%AC%A6%E8%BD%AC%E6%8D%A2"><span class="toc-number">12.8.</span> <span class="toc-text">字节和字符转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98IO%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="toc-number">12.9.</span> <span class="toc-text">磁盘IO工作机制：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%B1%E5%93%8D%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E7%9A%84%E5%9B%A0%E7%B4%A0%EF%BC%9A"><span class="toc-number">12.10.</span> <span class="toc-text">影响网络传输的因素：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BIO-NIO-AIO"><span class="toc-number">12.11.</span> <span class="toc-text">BIO. NIO. AIO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BIO-NIO-AIO%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90"><span class="toc-number">12.12.</span> <span class="toc-text">BIO. NIO. AIO适用场景分析:</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#jvm"><span class="toc-number">13.</span> <span class="toc-text">jvm</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%B7%B2%E6%AD%BB%EF%BC%9F"><span class="toc-number">13.1.</span> <span class="toc-text">判断对象是否已死？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E7%9A%84%E7%B1%BB%E8%A2%AB%E5%9B%9E%E6%94%B6%E7%9A%84%E6%9D%A1%E4%BB%B6%EF%BC%9A"><span class="toc-number">13.2.</span> <span class="toc-text">java的类被回收的条件：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">13.3.</span> <span class="toc-text">基本回收算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SavePoint%E5%AE%89%E5%85%A8%E7%82%B9%E5%92%8C%E5%AE%89%E5%85%A8%E5%8C%BA"><span class="toc-number">13.4.</span> <span class="toc-text">SavePoint安全点和安全区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">13.5.</span> <span class="toc-text">垃圾收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E4%B8%AD%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">13.6.</span> <span class="toc-text">JVM中并行与并发的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95-1"><span class="toc-number">13.7.</span> <span class="toc-text">基本回收算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%88%86%E4%BB%A3%E7%AE%97%E6%B3%95"><span class="toc-number">13.8.</span> <span class="toc-text">基于分代算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F%EF%BC%9A"><span class="toc-number">13.9.</span> <span class="toc-text">java运行时数据区域：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#kafka"><span class="toc-number">14.</span> <span class="toc-text">kafka</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lock"><span class="toc-number">15.</span> <span class="toc-text">lock</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E5%86%85%E5%AD%98%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%EF%BC%9A"><span class="toc-number">15.1.</span> <span class="toc-text">主内存和工作内存：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E6%97%8B%E9%94%81%EF%BC%9A"><span class="toc-number">15.2.</span> <span class="toc-text">什么是自旋锁：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E6%B6%88%E9%99%A4"><span class="toc-number">15.3.</span> <span class="toc-text">锁消除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%B2%97%E5%8C%96"><span class="toc-number">15.4.</span> <span class="toc-text">锁粗化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-number">15.5.</span> <span class="toc-text">偏向锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">15.6.</span> <span class="toc-text">轻量级锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile%E5%8F%98%E9%87%8F"><span class="toc-number">15.7.</span> <span class="toc-text">volatile变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS"><span class="toc-number">15.8.</span> <span class="toc-text">CAS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5%EF%BC%9F"><span class="toc-number">15.9.</span> <span class="toc-text">如何实现互斥同步？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E6%9C%89%E9%82%A3%E5%87%A0%E4%B8%AA%EF%BC%9F"><span class="toc-number">15.10.</span> <span class="toc-text">ReentrantLock的高级特性有那几个？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Esunchronized%E7%9A%84%E5%87%A0%E4%B8%AA%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9F"><span class="toc-number">15.11.</span> <span class="toc-text">关于sunchronized的几个注意点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7-%E5%8F%AF%E8%A7%81%E6%80%A7-%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">15.12.</span> <span class="toc-text">原子性. 可见性. 有序性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mongodb"><span class="toc-number">16.</span> <span class="toc-text">mongodb</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MongoDB%E7%AE%80%E4%BB%8B"><span class="toc-number">16.1.</span> <span class="toc-text">MongoDB简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">16.2.</span> <span class="toc-text">特点:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD"><span class="toc-number">16.3.</span> <span class="toc-text">功能:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E5%90%88"><span class="toc-number">16.4.</span> <span class="toc-text">适用场合:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E6%AF%94"><span class="toc-number">16.5.</span> <span class="toc-text">与传统数据库对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">16.6.</span> <span class="toc-text">索引</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mysql"><span class="toc-number">17.</span> <span class="toc-text">mysql</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql%E4%B8%BB%E8%A6%81%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%8C%85%E6%8B%ACInnoDB-MyISAM"><span class="toc-number">17.1.</span> <span class="toc-text">Mysql主要存储引擎包括InnoDB. MyISAM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E5%92%8CMyISAM%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">17.2.</span> <span class="toc-text">InnoDB和MyISAM的区别：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span class="toc-number">17.3.</span> <span class="toc-text">数值类型：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E7%B1%BB%E5%9E%8B"><span class="toc-number">17.4.</span> <span class="toc-text">日期类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#datetime%E5%92%8Ctimestamp%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">17.5.</span> <span class="toc-text">datetime和timestamp的区别：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#char-varchar-binary-varbinary-blob-text-enum%E5%92%8Cset"><span class="toc-number">17.6.</span> <span class="toc-text">char. varchar. binary. varbinary. blob. text. enum和set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">17.7.</span> <span class="toc-text">数据库隔离级别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">17.8.</span> <span class="toc-text">各种隔离级别出现的问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#netty"><span class="toc-number">18.</span> <span class="toc-text">netty</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8Netty"><span class="toc-number">18.1.</span> <span class="toc-text">为什么使用Netty?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Design-%E8%AE%BE%E8%AE%A1"><span class="toc-number">18.2.</span> <span class="toc-text">Design(设计)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ease-of-Use-%E6%98%93%E4%BA%8E%E4%BD%BF-%E7%94%A8"><span class="toc-number">18.3.</span> <span class="toc-text">Ease of Use(易于使 用)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Performance-%E6%80%A7%E8%83%BD"><span class="toc-number">18.4.</span> <span class="toc-text">Performance(性能)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Robustness-%E9%B2%81%E6%A3%92%E6%80%A7"><span class="toc-number">18.5.</span> <span class="toc-text">Robustness(鲁棒性)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Security-%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">18.6.</span> <span class="toc-text">Security(安全性)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Community-%E7%A4%BE%E5%8C%BA"><span class="toc-number">18.7.</span> <span class="toc-text">Community(社区)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#network"><span class="toc-number">19.</span> <span class="toc-text">network</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Netty-%E8%A7%A3%E5%86%B3TCP%E7%B2%98%E5%8C%85-x2F-%E6%8B%86%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">19.1.</span> <span class="toc-text">Netty 解决TCP粘包&#x2F;拆包问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#nginx"><span class="toc-number">20.</span> <span class="toc-text">nginx</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Nginx%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">20.1.</span> <span class="toc-text">Nginx能做什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-number">20.2.</span> <span class="toc-text">反向代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">20.3.</span> <span class="toc-text">负载均衡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">20.4.</span> <span class="toc-text">HTTP服务器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB"><span class="toc-number">20.5.</span> <span class="toc-text">动静分离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-number">20.6.</span> <span class="toc-text">正向代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Nginx%E7%83%AD%E9%83%A8%E7%BD%B2"><span class="toc-number">20.7.</span> <span class="toc-text">Nginx热部署</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis"><span class="toc-number">21.</span> <span class="toc-text">redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">21.1.</span> <span class="toc-text">redis数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">21.2.</span> <span class="toc-text">Redis的持久化方式：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%90%84%E7%A7%8D%E7%89%B9%E5%BE%81%E7%9A%84%E8%AF%95%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">21.3.</span> <span class="toc-text">Redis各种特征的试用场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#seckill"><span class="toc-number">22.</span> <span class="toc-text">seckill</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E7%9A%84%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%EF%BC%9A"><span class="toc-number">22.1.</span> <span class="toc-text">典型的秒杀系统：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%86%B3%E9%AB%98%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E5%B8%B8%E7%94%A8%E6%96%B9%E6%A1%88"><span class="toc-number">22.2.</span> <span class="toc-text">秒杀系统解决高并发问题常用方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8C%91%E6%88%98"><span class="toc-number">22.3.</span> <span class="toc-text">秒杀系统的挑战</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BA%94%E5%AF%B9%E7%AD%96%E7%95%A5"><span class="toc-number">22.4.</span> <span class="toc-text">秒杀系统的应对策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">22.5.</span> <span class="toc-text">秒杀系统架构设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E7%A7%92%E6%9D%80%E5%95%86%E5%93%81%E9%A1%B5%E9%9D%A2%E8%B4%AD%E4%B9%B0%E6%8C%89%E9%92%AE%E7%9A%84%E7%82%B9%E4%BA%AE"><span class="toc-number">22.6.</span> <span class="toc-text">如何控制秒杀商品页面购买按钮的点亮</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%8F%AA%E5%85%81%E8%AE%B8%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%8F%90%E4%BA%A4%E7%9A%84%E8%AE%A2%E5%8D%95%E8%A2%AB%E5%8F%91%E9%80%81%E5%88%B0%E8%AE%A2%E5%8D%95%E5%AD%90%E7%B3%BB%E7%BB%9F%E3%80%82"><span class="toc-number">22.7.</span> <span class="toc-text">如何只允许第一个提交的订单被发送到订单子系统。</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#service"><span class="toc-number">23.</span> <span class="toc-text">service</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%95%85%E9%9A%9C"><span class="toc-number">23.1.</span> <span class="toc-text">微服务故障</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%95%85%E9%9A%9C%E9%9A%94%E7%A6%BB"><span class="toc-number">23.2.</span> <span class="toc-text">服务故障隔离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E9%9A%94%E7%A6%BB%E6%8A%80%E6%9C%AF"><span class="toc-number">23.3.</span> <span class="toc-text">故障隔离技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RPC%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E9%9A%94%E7%A6%BB"><span class="toc-number">23.4.</span> <span class="toc-text">RPC通信链路隔离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E9%9A%94%E7%A6%BB"><span class="toc-number">23.5.</span> <span class="toc-text">微服务调度隔离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E6%9C%8D%E5%8A%A1%E4%BE%9D%E8%B5%96%E9%9A%94%E7%A6%BB"><span class="toc-number">23.6.</span> <span class="toc-text">第三方服务依赖隔离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8B%E9%9A%94%E7%A6%BB-Docker%E5%AE%B9%E5%99%A8"><span class="toc-number">23.7.</span> <span class="toc-text">微服务进程隔离(Docker容器)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E8%B7%AF%E7%94%B1%E5%AE%B9%E9%94%99"><span class="toc-number">23.8.</span> <span class="toc-text">分布式路由容错</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7"><span class="toc-number">23.9.</span> <span class="toc-text">服务降级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%86%94%E6%96%AD%E6%9C%BA%E5%88%B6"><span class="toc-number">23.10.</span> <span class="toc-text">熔断机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#spark"><span class="toc-number">24.</span> <span class="toc-text">spark</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSpark"><span class="toc-number">24.1.</span> <span class="toc-text">什么是Spark</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spark%E7%89%B9%E6%80%A7"><span class="toc-number">24.2.</span> <span class="toc-text">Spark特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spark%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F"><span class="toc-number">24.3.</span> <span class="toc-text">Spark生态系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spark%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84"><span class="toc-number">24.4.</span> <span class="toc-text">Spark体系架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spark%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84-1"><span class="toc-number">24.5.</span> <span class="toc-text">Spark体系架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E6%8D%A2%EF%BC%9A%E5%8F%98%E6%8D%A2%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E6%98%AF%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84RDD%E9%9B%86%E5%90%88%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E5%8D%95%E4%B8%AA%E5%80%BC%E3%80%82%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AA%E5%8F%98%E6%8D%A2%E6%96%B9%E6%B3%95%EF%BC%8C%E4%B8%8D%E4%BC%9A%E6%9C%89%E4%BB%BB%E4%BD%95%E6%B1%82%E5%80%BC%E8%AE%A1%E7%AE%97%EF%BC%8C%E5%AE%83%E5%8F%AA%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AARDD%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%EF%BC%8C%E7%84%B6%E5%90%8E%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84RDD%E3%80%82"><span class="toc-number">24.6.</span> <span class="toc-text">变换：变换的返回值是一个新的RDD集合，而不是单个值。调用一个变换方法，不会有任何求值计算，它只获取一个RDD作为参数，然后返回一个新的RDD。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E5%8A%A8%EF%BC%9A%E8%A1%8C%E5%8A%A8%E6%93%8D%E4%BD%9C%E8%AE%A1%E7%AE%97%E5%B9%B6%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%80%BC%E3%80%82%E5%BD%93%E5%9C%A8%E4%B8%80%E4%B8%AARDD%E5%AF%B9%E8%B1%A1%E4%B8%8A%E8%B0%83%E7%94%A8%E8%A1%8C%E5%8A%A8%E5%87%BD%E6%95%B0%E6%97%B6%EF%BC%8C%E4%BC%9A%E5%9C%A8%E8%BF%99%E4%B8%80%E6%97%B6%E5%88%BB%E8%AE%A1%E7%AE%97%E5%85%A8%E9%83%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%9F%A5%E8%AF%A2%E5%B9%B6%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E5%80%BC%E3%80%82"><span class="toc-number">24.7.</span> <span class="toc-text">行动：行动操作计算并返回一个新的值。当在一个RDD对象上调用行动函数时，会在这一时刻计算全部的数据处理查询并返回结果值。</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#synchronized"><span class="toc-number">25.</span> <span class="toc-text">synchronized</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E6%98%AFjava%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%8C%E6%98%AF%E4%B8%80%E7%A7%8D%E5%90%8C%E6%AD%A5%E9%94%81"><span class="toc-number">25.1.</span> <span class="toc-text">synchronized是java的关键字，是一种同步锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%B6%E9%95%BF%E5%BA%A6%E7%9A%84byte%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA%E8%B5%B7%E6%9D%A5%E6%AF%94%E4%BB%BB%E4%BD%95%E5%AF%B9%E8%B1%A1%E9%83%BD%E7%BB%8F%E6%B5%8E%EF%BC%8C%E7%94%9F%E6%88%900%E9%95%BF%E5%BA%A6%E7%9A%84byte-%E5%AF%B9%E8%B1%A1%E5%8F%AA%E9%9C%80%E8%A6%813%E6%9D%A1%E5%AD%97%E8%8A%82%E7%A0%81-%E8%80%8C%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAObject%E5%88%99%E9%9C%80%E8%A6%817%E6%AD%A5%E9%AA%A4%E3%80%82"><span class="toc-number">25.2.</span> <span class="toc-text">零长度的byte数组创建起来比任何对象都经济，生成0长度的byte[]对象只需要3条字节码. 而创建一个Object则需要7步骤。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">25.3.</span> <span class="toc-text">并发访问时需要注意事项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#system"><span class="toc-number">26.</span> <span class="toc-text">system</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BB%BA%E8%AE%AE%E8%B0%83%E5%B0%8F-TCP-%E5%8D%8F%E8%AE%AE%E7%9A%84-time-wait-%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4"><span class="toc-number">26.1.</span> <span class="toc-text">高并发服务器建议调小 TCP 协议的 time_wait 超时时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%A4%A7%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%80%E6%94%AF%E6%8C%81%E7%9A%84%E6%9C%80%E5%A4%A7%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84%E6%95%B0-File-Descriptor-%E7%AE%80%E5%86%99%E4%B8%BAfd"><span class="toc-number">26.2.</span> <span class="toc-text">调大服务器所支持的最大文件句柄数(File Descriptor,简写为fd)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%99-JVM-%E8%AE%BE%E7%BD%AE-XX-HeapDumpOnOutOfMemoryError-%E5%8F%82%E6%95%B0-%E8%AE%A9-JVM-%E7%A2%B0%E5%88%B0-OOM-%E5%9C%BA%E6%99%AF%E6%97%B6%E8%BE%93%E5%87%BA-dump-%E4%BF%A1%E6%81%AF"><span class="toc-number">26.3.</span> <span class="toc-text">给 JVM 设置-XX:+HeapDumpOnOutOfMemoryError 参数,让 JVM 碰到 OOM 场景时输出 dump 信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%85%E9%83%A8%E9%87%8D%E5%AE%9A%E5%90%91%E4%BD%BF%E7%94%A8-forward%EF%BC%8C%E5%A4%96%E9%83%A8%E9%87%8D%E5%AE%9A%E5%90%91%E5%9C%B0%E5%9D%80%E4%BD%BF%E7%94%A8-URL-%E6%8B%BC%E8%A3%85%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%9D%A5%E7%94%9F%E6%88%90-%E5%90%A6%E5%88%99-%E4%BC%9A%E5%B8%A6%E6%9D%A5-URL-%E7%BB%B4%E6%8A%A4%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E6%BD%9C%E5%9C%A8%E7%9A%84%E5%AE%89%E5%85%A8%E9%A3%8E%E9%99%A9%E3%80%82"><span class="toc-number">26.4.</span> <span class="toc-text">服务器内部重定向使用 forward，外部重定向地址使用 URL 拼装工具类来生成,否则 会带来 URL 维护不一致的问题和潜在的安全风险。</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#threadpoolexecutor"><span class="toc-number">27.</span> <span class="toc-text">threadpoolexecutor</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BB%8B%E7%BB%8D"><span class="toc-number">27.1.</span> <span class="toc-text">参数介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AF%B9%E6%8B%92%E7%BB%9D%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-number">27.2.</span> <span class="toc-text">线程池对拒绝任务的处理策略</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#transaction"><span class="toc-number">28.</span> <span class="toc-text">transaction</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E6%80%A7ACID%EF%BC%9A"><span class="toc-number">28.1.</span> <span class="toc-text">数据库事务的四个特性ACID：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#weakhashmap"><span class="toc-number">29.</span> <span class="toc-text">weakhashmap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#WeakHashMap"><span class="toc-number">29.1.</span> <span class="toc-text">WeakHashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WeekHashMap%E7%94%A8%E9%80%94%EF%BC%9A"><span class="toc-number">29.2.</span> <span class="toc-text">WeekHashMap用途：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">29.3.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#web"><span class="toc-number">30.</span> <span class="toc-text">web</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8C%96%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">30.1.</span> <span class="toc-text">静态化系统的特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E9%9D%99%E6%80%81%E5%8C%96%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">30.2.</span> <span class="toc-text">为什么要进行静态化架构设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8C%96%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">30.3.</span> <span class="toc-text">静态化系统的优点：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E6%94%B9%E9%80%A0%E7%B3%BB%E7%BB%9F"><span class="toc-number">30.4.</span> <span class="toc-text">如何动态改造系统</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#zk"><span class="toc-number">31.</span> <span class="toc-text">zk</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E8%A1%8C%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">31.1.</span> <span class="toc-text">流行的应用场景</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/3671369038/" title="反编译第三方jar包"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://czcsw-1256525464.cos.ap-chengdu.myqcloud.com/images/blog/20230414/1681405898521/300000298.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="反编译第三方jar包"/></a><div class="content"><a class="title" href="/posts/3671369038/" title="反编译第三方jar包">反编译第三方jar包</a><time datetime="2023-05-09T06:15:46.000Z" title="Created 2023-05-09 14:15:46">2023-05-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/712115305/" title="使用自建RocketMq消息队列调试服务"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://czcsw-1256525464.cos.ap-chengdu.myqcloud.com/images/blog/20230414/1681405898521/300000265.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="使用自建RocketMq消息队列调试服务"/></a><div class="content"><a class="title" href="/posts/712115305/" title="使用自建RocketMq消息队列调试服务">使用自建RocketMq消息队列调试服务</a><time datetime="2023-04-24T09:25:24.000Z" title="Created 2023-04-24 17:25:24">2023-04-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1361951458/" title="PlayFramework请求堵塞"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://czcsw-1256525464.cos.ap-chengdu.myqcloud.com/images/blog/20230414/1681405898521/300000232.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="PlayFramework请求堵塞"/></a><div class="content"><a class="title" href="/posts/1361951458/" title="PlayFramework请求堵塞">PlayFramework请求堵塞</a><time datetime="2023-04-24T09:20:35.000Z" title="Created 2023-04-24 17:20:35">2023-04-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2340987232/" title="数据库表结构导出"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://czcsw-1256525464.cos.ap-chengdu.myqcloud.com/images/blog/20230414/1681405898521/300000199.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库表结构导出"/></a><div class="content"><a class="title" href="/posts/2340987232/" title="数据库表结构导出">数据库表结构导出</a><time datetime="2023-04-24T09:18:03.000Z" title="Created 2023-04-24 17:18:03">2023-04-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1579996637/" title="Git删除远程已提交文件，保留本地副本"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://czcsw-1256525464.cos.ap-chengdu.myqcloud.com/images/blog/20230414/1681405898521/300000166.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git删除远程已提交文件，保留本地副本"/></a><div class="content"><a class="title" href="/posts/1579996637/" title="Git删除远程已提交文件，保留本地副本">Git删除远程已提交文件，保留本地副本</a><time datetime="2023-04-24T09:01:26.000Z" title="Created 2023-04-24 17:01:26">2023-04-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" href="mailto:2366314738@qq.com" title="email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://weibo.com/u/3453541994" title="微博"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a><img class="footer_mini_logo" title="返回顶部" onclick="anzhiyu.scrollToDest(0, 500)" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://czcsw-1256525464.cos.ap-chengdu.myqcloud.com/images/blog/20230401/Misaka.jpg" size="50px"/><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/GriMu" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://space.bilibili.com/3999900" title="Bilibili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div><div id="anzhiyu-footer"><div class="footer-group"><div class="footer-title">服务</div><div class="footer-links"><a class="footer-item" title="Chagpt Ai" target="_blank" href="https://chatai.chengzc.club/">Chagpt Ai</a><a class="footer-item" title="文档管理" target="_blank" href="https://doc.chengzc.club/">文档管理</a><a class="footer-item" title="开往" target="_blank" href="https://github.com/travellings-link/travellings">开往</a></div></div><div class="footer-group"><div class="footer-title">主题</div><div class="footer-links"><a class="footer-item" title="文档" target="_blank" href="https://blog.anheyu.com/docs/">文档</a><a class="footer-item" title="源码" target="_blank" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu">源码</a><a class="footer-item" title="更新日志" target="_blank" href="https://blog.anheyu.com/update/">更新日志</a></div></div><div class="footer-group"><div class="footer-title">导航</div><div class="footer-links"><a class="footer-item" title="即刻短文" target="_blank" href="/essay/">即刻短文</a><a class="footer-item" title="友链文章" target="_blank" href="/fcircle/">友链文章</a><a class="footer-item" title="留言板" target="_blank" href="/comments/">留言板</a></div></div><div class="footer-group"><div class="footer-title">协议</div><div class="footer-links"><a class="footer-item" title="隐私协议" target="_blank" href="/privacy/">隐私协议</a><a class="footer-item" title="Cookies" target="_blank" href="/cookies/">Cookies</a><a class="footer-item" title="版权协议" target="_blank" href="/copyright/">版权协议</a></div></div><div class="footer-group"><div class="footer-title-group"><div class="footer-title">友链</div><a class="random-friends-btn" id="footer-random-friends-btn" href="javascript:addFriendLinksInFooter();" title="换一批友情链接"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right"></i></a></div><div class="footer-links" id="friend-links-in-footer"></div></div></div><div class="copyright">&copy;2020 - 2023 By ChengZC</div><div id="workboard"><img class="workSituationImg boardsign" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://czcsw-1256525464.cos.ap-chengdu.myqcloud.com/images/blog/20230402/ChengZC-%E4%B8%8A%E7%8F%AD%E6%91%B8%E9%B1%BC%E4%B8%AD.svg" alt="距离月入25k也就还差一个大佬带我~" title="距离月入25k也就还差一个大佬带我~"/><div id="runtimeTextTip"></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://cloud.tencent.com/" style="margin-inline:5px" data-title="本站使用腾讯云为静态资源提供CDN加速" title="本站使用腾讯云为静态资源提供CDN加速"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://czcsw-1256525464.cos.ap-chengdu.myqcloud.com/images/blog/20230402/CDN-%E8%85%BE%E8%AE%AF%E4%BA%91-3693F3.svg" alt="本站使用腾讯云为静态资源提供CDN加速"/></a><a class="github-badge" target="_blank" href="https://beian.miit.gov.cn/" style="margin-inline:5px" data-title="本站已在鄂进行备案" title="本站已在鄂进行备案"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://czcsw-1256525464.cos.ap-chengdu.myqcloud.com/images/blog/20230403/%E9%84%82ICP%E5%A4%8719005094%E5%8F%B7-1.svg" alt="本站已在鄂进行备案"/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/Copyright-BY-NC-SA.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"/></a></p></div></footer></div></div></div><div id="sidebar"><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://czcsw-1256525464.cos.ap-chengdu.myqcloud.com/images/blog/20230401/Misaka.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">Articles</div><div class="length-num">21</div></a><a href="/tags/" title="tag"><div class="headline">Tags</div><div class="length-num">25</div></a><a href="/categories/" title="category"><div class="headline">Categories</div><div class="length-num">3</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=8295035317&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch_commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="Back To Top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8295035317" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://music.163.com/#/my/m/music/playlist?id=26749266&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script><div><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.4.0/source/js/utils.js"></script><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.4.0/source/js/main.js"></script><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.4.0/source/js/tw_cn.js"></script><script src="https://npm.elemecdn.com/@fancyapps/ui@4.0.31/dist/fancybox.umd.js"></script><script src="https://npm.elemecdn.com/instant.page@5.1.1/instantpage.js" type="module"></script><script src="https://npm.elemecdn.com/vanilla-lazyload@17.3.1/dist/lazyload.iife.min.js"></script><script src="https://npm.elemecdn.com/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("10/10/2018 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 1.4.0",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#3b70fc",
      "",
      "color:#3b70fc",
      "color:#3b70fc",
      "",
      "color:#3b70fc",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 ChengZC 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("10/10/2018 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      img.src = "https://czcsw-1256525464.cos.ap-chengdu.myqcloud.com/images/blog/20230402/ChengZC-%E4%B8%8B%E7%8F%AD%E5%95%A6.svg";
      img.title = "下班了就该开开心心的玩耍，嘿嘿~";
      img.alt = "下班了就该开开心心的玩耍，嘿嘿~";

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.4.0/source/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.chengzc.club',
      region: '',
      onCommentLoaded: function () {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.chengzc.club',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init();
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://npm.elemecdn.com/twikoo@1.6.16/dist/twikoo.all.min.js').then(runFn)
  }
  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[image]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[link]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[code]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://twikoo.chengzc.club',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "Unable to get the data, please make sure the settings are correct."
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://npm.elemecdn.com/twikoo@1.6.16/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick}</span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += 'No Comment'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "visitor@anheyu.com";</script><script>//动态标题
let leaveTitle = 'w(ﾟДﾟ)w 不要走！再看看嘛！';
let backTitle = '♪(^∇^*)欢迎肥来！';
let OriginTitile = document.title
let titleTime
document.addEventListener('visibilitychange', function () {
  if (document.hidden) {
    //离开当前页面时标签显示内容
    document.title = leaveTitle
    clearTimeout(titleTime)
  } else {
    //返回当前页面时标签显示内容
    document.title = backTitle + OriginTitile
    //两秒后变回正常标题
    titleTime = setTimeout(function () {
      document.title = OriginTitile
    }, 2000)
  }
})</script><script data-pjax="true">if (document.querySelector(".comment-barrage")){
  var commentBarrageConfig = {
    maxBarrage: 1,
    barrageTime: 4000,
    twikooUrl: "https://twikoo.chengzc.club",
    accessToken: "",
    mailMd5: "",
    pageUrl: window.location.pathname,
    barrageTimer: [],
    barrageList: [],
    barrageIndex: 0,
    dom: document.querySelector(".comment-barrage"),
  };
  var commentInterval = null;
  var hoverOnCommentBarrage = false;
  
  document.querySelector(".comment-barrage").addEventListener("mouseenter", function() {
    hoverOnCommentBarrage = true;
  });
  document.querySelector(".comment-barrage").addEventListener("mouseleave", function() {
    hoverOnCommentBarrage = false;
  });

  function initCommentBarrage() {
    if (!commentBarrageConfig.dom) return;

    var data = JSON.stringify({
      event: "COMMENT_GET",
      "commentBarrageConfig.accessToken": commentBarrageConfig.accessToken,
      url: commentBarrageConfig.pageUrl,
    });
    var xhr = new XMLHttpRequest();
    xhr.withCredentials = true;
    xhr.addEventListener("readystatechange", function () {
      if (this.readyState === 4 && this.responseText) {
        commentBarrageConfig.barrageList = commentLinkFilter(JSON.parse(this.responseText).data);
        commentBarrageConfig.dom.innerHTML = "";
      }
    });
    xhr.open("POST", commentBarrageConfig.twikooUrl);
    xhr.setRequestHeader("Content-Type", "application/json");
    xhr.send(data);

    clearInterval(commentInterval);
    commentInterval = null;

    commentInterval = setInterval(() => {
      if (commentBarrageConfig.barrageList.length && !hoverOnCommentBarrage) {
        popCommentBarrage(commentBarrageConfig.barrageList[commentBarrageConfig.barrageIndex]);
        commentBarrageConfig.barrageIndex += 1;
        commentBarrageConfig.barrageIndex %= commentBarrageConfig.barrageList.length;
      }
      if (
        commentBarrageConfig.barrageTimer.length >
          (commentBarrageConfig.barrageList.length > commentBarrageConfig.maxBarrage
            ? commentBarrageConfig.maxBarrage
            : commentBarrageConfig.barrageList.length) &&
        !hoverOnCommentBarrage
      ) {
        removeCommentBarrage(commentBarrageConfig.barrageTimer.shift());
      }
    }, commentBarrageConfig.barrageTime);
  }

  function commentLinkFilter(data) {
    data.sort((a, b) => {
      return a.created - b.created;
    });
    let newData = [];
    data.forEach(item => {
      newData.push(...getCommentReplies(item));
    });
    return newData;
  }

  function getCommentReplies(item) {
    if (item.replies) {
      let replies = [item];
      item.replies.forEach(item => {
        replies.push(...getCommentReplies(item));
      });
      return replies;
    } else {
      return [];
    }
  }

  function popCommentBarrage(data) {
    let barrage = document.createElement("div");
    barrage.className = "comment-barrage-item";
    barrage.innerHTML = `
        <div class="barrageHead">
          <a class="barrageTitle ${
            data.mailMd5 === commentBarrageConfig.mailMd5 ? "barrageBloggerTitle" : ""
          }" href="javascript:anzhiyu.scrollTo('#post-comment')"">
            ${data.mailMd5 === commentBarrageConfig.mailMd5 ? "博主" : "热评"}
          </a>
          <div class="barrageNick">${data.nick}</div>
          <img class="nolazyload barrageAvatar" src="https://cravatar.cn/avatar/${data.mailMd5}"/>
          <a class="comment-barrage-close" href="javascript:anzhiyu.switchCommentBarrage()"><i class="anzhiyufont anzhiyu-icon-xmark"></i></a>
        </div>
        <a class="barrageContent" href="#${data.id}">
          <object>${data.comment}</object>
        </a>
      `;
    commentBarrageConfig.barrageTimer.push(barrage);
    commentBarrageConfig.dom.append(barrage);
  }

  function removeCommentBarrage(barrage) {
    barrage.className = "comment-barrage-item out";

    setTimeout(() => {
      if (commentBarrageConfig.dom && commentBarrageConfig.dom.contains(barrage)) {
        commentBarrageConfig.dom.removeChild(barrage);
      }
      }, 1000);
    }

    // 自动隐藏
    const commentEntryCallback = (entries) => {
      const commentBarrage = document.querySelector(".comment-barrage");
      const postComment = document.getElementById("post-comment");

      entries.forEach(entry => {
        if (postComment && commentBarrage && document.body.clientWidth > 768) {
          commentBarrage.style.bottom = entry.isIntersecting ? "-200px" : "0";
        }
      });
    };
    // 创建IntersectionObserver实例
    const observer = new IntersectionObserver(commentEntryCallback, {
      root: null,
      rootMargin: "0px",
      threshold: 0
    });
    // 监视目标元素
    const postCommentTarget = document.getElementById("post-comment");
    if (postCommentTarget) {
      observer.observe(postCommentTarget);
    }

    initCommentBarrage();

    if (localStorage.getItem("commentBarrageSwitch") !== "false") {
      document.querySelector(".comment-barrage").style.display = "flex";
      document.querySelector(".menu-commentBarrage-text").textContent = "关闭热评";
    } else {
      document.querySelector(".comment-barrage").style.display = "none";
      document.querySelector(".menu-commentBarrage-text").textContent = "显示热评";
    }

    document.addEventListener("pjax:send", function () {
      clearInterval(commentInterval);
    });

  }</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script>// 初始化函数
let rm = {};

//禁止图片与超链接拖拽
let aElements = document.getElementsByTagName("a");
for (let i = 0; i < aElements.length; i++) {
  aElements[i].setAttribute("draggable", "false");
  let imgElements = aElements[i].getElementsByTagName("img");
  for (let j = 0; j < imgElements.length; j++) {
    imgElements[j].setAttribute("draggable", "false");
  }
}

// 显示菜单
rm.showRightMenu = function (isTrue, x = 0, y = 0) {
  console.info(x, y)
  let rightMenu = document.getElementById("rightMenu");
  rightMenu.style.top = x + "px";
  rightMenu.style.left = y + "px";
  if (isTrue) {
    rightMenu.style.display = "block";
    stopMaskScroll();
  } else {
    rightMenu.style.display = "none";
  }
};

// 隐藏菜单
rm.hideRightMenu = function () {
  rm.showRightMenu(false);
  let rightMenuMask = document.querySelector("#rightmenu-mask");
  rightMenuMask.style.display = "none";
};

// 尺寸
let rmWidth = document.getElementById("rightMenu").offsetWidth;
let rmHeight = document.getElementById("rightMenu").offsetHeight;

// 重新定义尺寸
rm.reloadrmSize = function () {
  rightMenu.style.visibility = "hidden";
  rightMenu.style.display = "block";
  // 获取宽度和高度
  rmWidth = document.getElementById("rightMenu").offsetWidth;
  rmHeight = document.getElementById("rightMenu").offsetHeight;
  rightMenu.style.visibility = "visible";
};

// 获取点击的href
let domhref = "";
let domImgSrc = "";
let globalEvent = null;

var oncontextmenuFunction = function (event) {
  if (document.body.clientWidth > 768) {
    let pageX = event.clientX + 10; //加10是为了防止显示时鼠标遮在菜单上
    let pageY = event.clientY;

    //其他额外菜单
    const $rightMenuOther = document.querySelector(".rightMenuOther");
    const $rightMenuPlugin = document.querySelector(".rightMenuPlugin");
    const $rightMenuCopyText = document.querySelector("#menu-copytext");
    const $rightMenuPasteText = document.querySelector("#menu-pastetext");
    const $rightMenuCommentText = document.querySelector("#menu-commenttext");
    const $rightMenuNewWindow = document.querySelector("#menu-newwindow");
    const $rightMenuNewWindowImg = document.querySelector("#menu-newwindowimg");
    const $rightMenuCopyLink = document.querySelector("#menu-copylink");
    const $rightMenuCopyImg = document.querySelector("#menu-copyimg");
    const $rightMenuDownloadImg = document.querySelector("#menu-downloadimg");
    const $rightMenuSearch = document.querySelector("#menu-search");
    const $rightMenuSearchBaidu = document.querySelector("#menu-searchBaidu");
    const $rightMenuMusicToggle = document.querySelector("#menu-music-toggle");
    const $rightMenuMusicBack = document.querySelector("#menu-music-back");
    const $rightMenuMusicForward = document.querySelector("#menu-music-forward");
    const $rightMenuMusicPlaylist = document.querySelector("#menu-music-playlist");
    const $rightMenuMusicCopyMusicName = document.querySelector("#menu-music-copyMusicName");

    let href = event.target.href;
    let imgsrc = event.target.currentSrc;

    // 判断模式 扩展模式为有事件
    let pluginMode = false;
    $rightMenuOther.style.display = "block";
    globalEvent = event;

    // 检查是否需要复制 是否有选中文本
    if (selectTextNow && window.getSelection()) {
      pluginMode = true;
      $rightMenuCopyText.style.display = "block";
      $rightMenuCommentText.style.display = "block";
      $rightMenuSearch.style.display = "block";
      $rightMenuSearchBaidu.style.display = "block";
    } else {
      $rightMenuCopyText.style.display = "none";
      $rightMenuCommentText.style.display = "none";
      $rightMenuSearchBaidu.style.display = "none";
      $rightMenuSearch.style.display = "none";
    }

    //检查是否右键点击了链接a标签
    if (href) {
      pluginMode = true;
      $rightMenuNewWindow.style.display = "block";
      $rightMenuCopyLink.style.display = "block";
      domhref = href;
    } else {
      $rightMenuNewWindow.style.display = "none";
      $rightMenuCopyLink.style.display = "none";
    }

    //检查是否需要复制图片
    if (imgsrc) {
      pluginMode = true;
      $rightMenuCopyImg.style.display = "block";
      $rightMenuDownloadImg.style.display = "block";
      $rightMenuNewWindowImg.style.display = "block";
      document.getElementById("rightMenu").style.width="12rem"
      domImgSrc = imgsrc;
    } else {
      $rightMenuCopyImg.style.display = "none";
      $rightMenuDownloadImg.style.display = "none";
      $rightMenuNewWindowImg.style.display = "none";
    }

    // 判断是否为输入框
    if (event.target.tagName.toLowerCase() === "input" || event.target.tagName.toLowerCase() === "textarea") {
      pluginMode = true;
      $rightMenuPasteText.style.display = "block";
    } else {
      $rightMenuPasteText.style.display = "none";
    }
    const navMusicEl = document.querySelector("#nav-music");
    //判断是否是音乐
    if (navMusicEl && navMusicEl.contains(event.target)) {
      pluginMode = true;
      $rightMenuMusicToggle.style.display = "block";
      $rightMenuMusicBack.style.display = "block";
      $rightMenuMusicForward.style.display = "block";
      $rightMenuMusicPlaylist.style.display = "block";
      $rightMenuMusicCopyMusicName.style.display = "block";
    } else {
      $rightMenuMusicToggle.style.display = "none";
      $rightMenuMusicBack.style.display = "none";
      $rightMenuMusicForward.style.display = "none";
      $rightMenuMusicPlaylist.style.display = "none";
      $rightMenuMusicCopyMusicName.style.display = "none";
    }

    // 如果不是扩展模式则隐藏扩展模块
    if (pluginMode) {
      $rightMenuOther.style.display = "none";
      $rightMenuPlugin.style.display = "block";
    } else {
      $rightMenuPlugin.style.display = "none";
    }

    rm.reloadrmSize();

    // 鼠标默认显示在鼠标右下方，当鼠标靠右或靠下时，将菜单显示在鼠标左方\上方
    if (pageX + rmWidth > window.innerWidth) {
      pageX -= rmWidth + 10;
    }
    if (pageY + rmHeight > window.innerHeight) {
      pageY -= pageY + rmHeight - window.innerHeight;
    }

    rm.showRightMenu(true, pageY, pageX);
    document.getElementById("rightmenu-mask").style.display = "flex";
    return false;
  }
};

// 监听右键初始化
window.oncontextmenu = oncontextmenuFunction

// 下载图片状态
rm.downloadimging = false;

// 复制图片到剪贴板
rm.writeClipImg = function (imgsrc) {
  console.log("按下复制");
  rm.hideRightMenu();
  anzhiyu.snackbarShow("正在下载中，请稍后", false, 10000);
  if (rm.downloadimging == false) {
    rm.downloadimging = true;
    setTimeout(function () {
      copyImage(imgsrc);
      anzhiyu.snackbarShow("复制成功！图片已添加盲水印，请遵守版权协议");
      rm.downloadimging = false;
    }, "10000");
  }
};

function imageToBlob(imageURL) {
  const img = new Image();
  const c = document.createElement("canvas");
  const ctx = c.getContext("2d");
  img.crossOrigin = "";
  img.src = imageURL;
  return new Promise(resolve => {
    img.onload = function () {
      c.width = this.naturalWidth;
      c.height = this.naturalHeight;
      ctx.drawImage(this, 0, 0);
      c.toBlob(
        blob => {
          // here the image is a blob
          resolve(blob);
        },
        "image/png",
        0.75
      );
    };
  });
}

async function copyImage(imageURL) {
  const blob = await imageToBlob(imageURL);
  const item = new ClipboardItem({ "image/png": blob });
  navigator.clipboard.write([item]);
}

rm.copyUrl = function (id) {
  const input = document.createElement("input"); // Create a new <input> element
  input.id = "copyVal"; // Set the id of the new element to "copyVal"
  document.body.appendChild(input); // Append the new element to the end of the <body> element
  
  const text = id;
  input.value = text;
  input.select();
  input.setSelectionRange(0, input.value.length);
  document.execCommand("copy");
  
  input.remove(); // Remove the <input> element from the DOM
};

function stopMaskScroll() {
  if (document.getElementById("rightmenu-mask")) {
    let xscroll = document.getElementById("rightmenu-mask");
    xscroll.addEventListener(
      "mousewheel",
      function (e) {
        //阻止浏览器默认方法
        rm.hideRightMenu();
        // e.preventDefault();
      },
      { passive: true }
    );
  }
  if (document.getElementById("rightMenu")) {
    let xscroll = document.getElementById("rightMenu");
    xscroll.addEventListener(
      "mousewheel",
      function (e) {
        //阻止浏览器默认方法
        rm.hideRightMenu();
        // e.preventDefault();
      },
      { passive: true }
    );
  }
}

rm.rightmenuCopyText = function (txt) {
  if (navigator.clipboard) {
    navigator.clipboard.writeText(txt);
  }
  rm.hideRightMenu();
};

rm.copyPageUrl = function (url) {
  if (!url) {
    url = window.location.href;
  }
  rm.copyUrl(url);
  anzhiyu.snackbarShow("复制本页链接地址成功", false, 2000);
  rm.hideRightMenu();
};

rm.sharePage = function () {
  var content = window.location.href;
  rm.copyUrl(url);
  anzhiyu.snackbarShow("复制本页链接地址成功", false, 2000);
  rm.hideRightMenu();
};

// 复制当前选中文本
var selectTextNow = "";
document.onmouseup = document.ondblclick = selceText;

function selceText() {
  var txt;
  if (document.selection) {
    txt = document.selection.createRange().text;
  } else {
    txt = window.getSelection().toString();
  }
  selectTextNow = txt !== "" ? txt : "";
}

// 读取剪切板
rm.readClipboard = function () {
  if (navigator.clipboard) {
    navigator.clipboard.readText().then(clipText => rm.insertAtCaret(globalEvent.target, clipText));
  }
};

// 粘贴文本到焦点
rm.insertAtCaret = function (elemt, value) {
  const startPos = elemt.selectionStart,
    endPos = elemt.selectionEnd;
  if (document.selection) {
    elemt.focus();
    var sel = document.selection.createRange();
    sel.text = value;
    elemt.focus();
  } else {
    if (startPos || startPos == "0") {
      var scrollTop = elemt.scrollTop;
      elemt.value = elemt.value.substring(0, startPos) + value + elemt.value.substring(endPos, elemt.value.length);
      elemt.focus();
      elemt.selectionStart = startPos + value.length;
      elemt.selectionEnd = startPos + value.length;
      elemt.scrollTop = scrollTop;
    } else {
      elemt.value += value;
      elemt.focus();
    }
  }
};

//粘贴文本
rm.pasteText = function () {
  const result = rm.readClipboard() || "";
  rm.hideRightMenu();
};

//引用到评论
rm.rightMenuCommentText = function (txt) {
  rm.hideRightMenu();
  const postCommentDom = document.getElementById("post-comment");
  var domTop = postCommentDom.offsetTop;
  window.scrollTo(0, domTop - 80);
  if (txt == "undefined" || txt == "null") txt = "好棒！";
  function setText() {
    setTimeout(() => {
      var input = document.getElementsByClassName("el-textarea__inner")[0];
      if (!input) setText();
      let evt = document.createEvent("HTMLEvents");
      evt.initEvent("input", true, true);
      let inputValue = replaceAll(txt, "\n", "\n> ");
      input.value = "> " + inputValue + "\n\n";
      input.dispatchEvent(evt);
      input.focus();
      input.setSelectionRange(-1, -1);
      if (document.getElementById("comment-tips")) {
        document.getElementById("comment-tips").classList.add("show");
      }
    }, 100);
  }
  setText();
};

//替换所有内容
function replaceAll(string, search, replace) {
  return string.split(search).join(replace);
}

// 百度搜索
rm.searchBaidu = function () {
  anzhiyu.snackbarShow("即将跳转到百度搜索", false, 2000);
  setTimeout(function () {
    window.open("https://www.baidu.com/s?wd=" + selectTextNow);
  }, "2000");
  rm.hideRightMenu();
};

//分享链接
rm.copyLink = function () {
  rm.rightmenuCopyText(domhref);
  anzhiyu.snackbarShow("已复制链接地址");
};

function addRightMenuClickEvent() {
  // 添加点击事件
  document.getElementById("menu-backward").addEventListener("click", function () {
  window.history.back();
    rm.hideRightMenu();
  });

  document.getElementById("menu-forward").addEventListener("click", function () {
    window.history.forward();
    rm.hideRightMenu();
  });

  document.getElementById("menu-refresh").addEventListener("click", function () {
    window.location.reload();
  });

  document.getElementById("menu-top").addEventListener("click", function () {
    anzhiyu.scrollToDest(0, 500);
    rm.hideRightMenu();
  });

  const menuLinks = document.querySelectorAll(".menu-link");
  menuLinks.forEach(function (link) {
    link.addEventListener("click", rm.hideRightMenu);
  });

  document.getElementById("menu-darkmode").addEventListener("click", anzhiyu.switchDarkMode);

  document.getElementById("menu-home") && document.getElementById("menu-home").addEventListener("click", function () {
    window.location.href = window.location.origin;
  });

  document.getElementById("menu-randomPost").addEventListener("click", function () {
    toRandomPost();
  });

  document.getElementById("menu-commentBarrage").addEventListener("click", anzhiyu.switchCommentBarrage);

  document.getElementById("rightmenu-mask").addEventListener("click", rm.hideRightMenu);

  document.getElementById("rightmenu-mask").addEventListener("contextmenu", function (event) {
    rm.hideRightMenu();
    event.preventDefault(); // Prevent the default context menu from appearing
  });

  document.getElementById("menu-copy").addEventListener("click", rm.copyPageUrl);

  document.getElementById("menu-pastetext").addEventListener("click", rm.pasteText);

  document.getElementById("menu-copytext").addEventListener("click", function () {
    rm.rightmenuCopyText(selectTextNow);
    anzhiyu.snackbarShow("复制成功，复制和转载请标注本文地址");
  });

  document.getElementById("menu-commenttext").addEventListener("click", function () {
    rm.rightMenuCommentText(selectTextNow);
  });

  document.getElementById("menu-newwindow").addEventListener("click", function () {
    window.open(domhref, "_blank");
    rm.hideRightMenu();
  });

  document.getElementById("menu-copylink").addEventListener("click", rm.copyLink);

  document.getElementById("menu-downloadimg").addEventListener("click", function () {
    anzhiyu.downloadImage(domImgSrc, "anzhiyu");
  });

  document.getElementById("menu-newwindowimg").addEventListener("click", function () {
    window.open(domImgSrc, "_blank");
    rm.hideRightMenu();
  });

  document.getElementById("menu-copyimg").addEventListener("click", function () {
    rm.writeClipImg(domImgSrc);
  });

  document.getElementById("menu-searchBaidu").addEventListener("click", rm.searchBaidu);

  //音乐
  document.getElementById("menu-music-toggle").addEventListener("click", anzhiyu.musicToggle);

  document.getElementById("menu-music-back").addEventListener("click", anzhiyu.musicSkipBack);

  document.getElementById("menu-music-forward").addEventListener("click", anzhiyu.musicSkipForward);

  document.getElementById("menu-music-copyMusicName").addEventListener("click", function () {
    rm.rightmenuCopyText(anzhiyu.musicGetName());
    anzhiyu.snackbarShow("复制歌曲名称成功", false, 3000);
  });

}

addRightMenuClickEvent();</script><script data-pjax>var themeColorMeta = document.querySelector('meta[name="theme-color"]');
var pageHeaderEl = document.getElementById("page-header");
var navMusicEl = document.getElementById("nav-music");
var consoleEl = document.getElementById("console");
// 已随机的歌曲
var selectRandomSong = [];
// 音乐默认声音大小
var musicVolume = 0.8;
// 是否切换了周杰伦音乐列表
var changeMusicListFlag = false;
// 当前默认播放列表
var defaultPlayMusicList = [];

document.getElementById("page-name").innerText = document.title.split(" | 才学浅")[0];
anzhiyu.initIndexEssay();
anzhiyu.changeTimeInEssay();
anzhiyu.removeBodyPaceClass();
anzhiyu.qrcodeCreate();
anzhiyu.changeTimeInAlbumDetail();
anzhiyu.reflashEssayWaterFall();
anzhiyu.sayhi();
anzhiyu.stopImgRightDrag();
anzhiyu.addNavBackgroundInit();
anzhiyu.setValueToBodyType();
anzhiyu.catalogActive();
anzhiyu.tagsPageActive();
anzhiyu.categoriesBarActive();
anzhiyu.topCategoriesBarScroll();
anzhiyu.switchRightClickMenuHotReview();
anzhiyu.getCustomPlayList();
anzhiyu.addEventListenerConsoleMusicList(false);
setTimeout(() => {
  if (typeof addFriendLinksInFooter === "function") {
    addFriendLinksInFooter();
  }
}, 200)</script><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.1.4/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://npm.elemecdn.com/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://npm.elemecdn.com/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://npm.elemecdn.com/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div></body></html>